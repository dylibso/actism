{
  "version": 3,
  "sources": ["../../node_modules/balanced-match/index.js", "../../node_modules/brace-expansion/index.js", "../../src/polyfills/node-capabilities.ts", "../../src/manifest.ts", "../../src/polyfills/response-to-module.ts", "../../src/interfaces.ts", "../../src/call-context.ts", "../../src/polyfills/node-wasi.ts", "../../src/foreground-plugin.ts", "../worker/node/worker-url.ts", "../../src/background-plugin.ts", "../../node_modules/minimatch/src/index.ts", "../../node_modules/minimatch/src/assert-valid-pattern.ts", "../../node_modules/minimatch/src/brace-expressions.ts", "../../node_modules/minimatch/src/unescape.ts", "../../node_modules/minimatch/src/ast.ts", "../../node_modules/minimatch/src/escape.ts", "../../src/polyfills/node-minimatch.ts", "../../src/mod.ts"],
  "sourcesContent": ["'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "import type { Capabilities } from '../interfaces.ts';\n\nexport const CAPABILITIES: Capabilities = {\n  // When false, shared buffers have to be copied to an array\n  // buffer before passing to Text{En,De}coding()\n  allowSharedBufferCodec: false,\n\n  // Whether or not the manifest supports the \"path:\" key.\n  manifestSupportsPaths: true,\n\n  // Whether or not cross-origin checks are enforced on this platform.\n  crossOriginChecksEnforced: false,\n\n  fsAccess: true,\n\n  hasWorkerCapability: true,\n\n  supportsWasiPreview1: true,\n\n  extismStdoutEnvVarSet: Boolean(process.env.EXTISM_ENABLE_WASI_OUTPUT),\n};\n", "import type {\n  Manifest,\n  ManifestWasmUrl,\n  ManifestWasmData,\n  ManifestWasmPath,\n  ManifestWasmResponse,\n  ManifestWasmModule,\n  ManifestLike,\n} from './interfaces.ts';\nimport { readFile } from './polyfills/node-fs.ts';\nimport { responseToModule } from './polyfills/response-to-module.ts';\n\nasync function _populateWasmField(candidate: ManifestLike, _fetch: typeof fetch): Promise<ManifestLike> {\n  if (candidate instanceof ArrayBuffer) {\n    return { wasm: [{ data: new Uint8Array(candidate as ArrayBuffer) }] };\n  }\n\n  if (candidate instanceof WebAssembly.Module) {\n    return { wasm: [{ module: candidate as WebAssembly.Module }] };\n  }\n\n  if (typeof candidate === 'string') {\n    if (candidate.search(/^\\s*\\{/g) === 0) {\n      return JSON.parse(candidate);\n    }\n\n    if (candidate.search(/^(https?|file):\\/\\//) !== 0) {\n      return { wasm: [{ path: candidate }] };\n    }\n\n    candidate = new URL(candidate);\n  }\n\n  if (candidate instanceof Response || candidate?.constructor?.name === 'Response') {\n    const response: Response = candidate as Response;\n    const contentType = response.headers.get('content-type') || 'application/octet-stream';\n\n    switch (contentType.split(';')[0]) {\n      case 'application/octet-stream':\n      case 'application/wasm':\n        return { wasm: [{ response }] };\n      case 'application/json':\n      case 'text/json':\n        return _populateWasmField(JSON.parse(await response.text()), _fetch);\n      default:\n        throw new TypeError(\n          `While processing manifest URL \"${response.url}\"; expected content-type of \"text/json\", \"application/json\", \"application/octet-stream\", or \"application/wasm\"; got \"${contentType}\" after stripping off charset.`,\n        );\n    }\n  }\n\n  if (candidate instanceof URL) {\n    return _populateWasmField(await _fetch(candidate, { redirect: 'follow' }), _fetch);\n  }\n\n  if (!('wasm' in candidate)) {\n    throw new TypeError('Expected \"wasm\" key in manifest');\n  }\n\n  if (!Array.isArray(candidate.wasm)) {\n    throw new TypeError('Expected \"manifest.wasm\" to be array');\n  }\n\n  const badItemIdx = candidate.wasm.findIndex(\n    (item) =>\n      !('data' in item) && !('url' in item) && !('path' in item) && !('module' in item) && !('response' in item),\n  );\n  if (badItemIdx > -1) {\n    throw new TypeError(\n      `Expected every item in \"manifest.wasm\" to include either a \"data\", \"url\", or \"path\" key; got bad item at index ${badItemIdx}`,\n    );\n  }\n\n  return { ...(candidate as Manifest) };\n}\n\nasync function intoManifest(candidate: ManifestLike, _fetch: typeof fetch = fetch): Promise<Manifest> {\n  const manifest = (await _populateWasmField(candidate, _fetch)) as Manifest;\n  manifest.config ??= {};\n  return manifest;\n}\n\nexport async function toWasmModuleData(\n  input: ManifestLike,\n  _fetch: typeof fetch,\n): Promise<[string[], WebAssembly.Module[]]> {\n  const names: string[] = [];\n\n  const manifest = await intoManifest(input, _fetch);\n\n  const manifestsWasm = await Promise.all(\n    manifest.wasm.map(async (item, idx) => {\n      let module: WebAssembly.Module;\n      let buffer: ArrayBuffer | undefined;\n      if ((item as ManifestWasmData).data) {\n        const data = (item as ManifestWasmData).data;\n        buffer = data.buffer ? data.buffer : data;\n        module = await WebAssembly.compile(data);\n      } else if ((item as ManifestWasmPath).path) {\n        const path = (item as ManifestWasmPath).path;\n        const data = await readFile(path);\n        buffer = data.buffer as ArrayBuffer;\n        module = await WebAssembly.compile(data);\n      } else if ((item as ManifestWasmUrl).url) {\n        const response = await _fetch((item as ManifestWasmUrl).url, {\n          headers: {\n            accept: 'application/wasm;q=0.9,application/octet-stream;q=0.8',\n            'user-agent': 'extism',\n          },\n        });\n        const result = await responseToModule(response, Boolean(item.hash));\n        buffer = result.data;\n        module = result.module;\n      } else if ((item as ManifestWasmResponse).response) {\n        const result = await responseToModule((item as ManifestWasmResponse).response, Boolean(item.hash));\n        buffer = result.data;\n        module = result.module;\n      } else if ((item as ManifestWasmModule).module) {\n        (<any>names[idx]) = item.name ?? String(idx);\n        module = (item as ManifestWasmModule).module;\n      } else {\n        throw new Error(\n          `Unrecognized wasm item at index ${idx}. Keys include: \"${Object.keys(item).sort().join(',')}\"`,\n        );\n      }\n\n      if (item.hash) {\n        if (!buffer) {\n          throw new Error('Item specified a hash but WebAssembly.Module source data is unavailable for hashing');\n        }\n\n        const hashBuffer = new Uint8Array(await crypto.subtle.digest('SHA-256', buffer));\n        const checkBuffer = new Uint8Array(32);\n        let eq = true;\n        for (let i = 0; i < 32; ++i) {\n          checkBuffer[i] = parseInt(item.hash.slice(i << 1, (i << 1) + 2), 16);\n          // do not exit early: we want to do a constant time comparison\n          eq = eq && checkBuffer[i] === hashBuffer[i];\n        }\n        const hashAsString = () => [...hashBuffer].map((xs) => xs.toString(16).padStart(2, '0')).join('');\n\n        if (!eq) {\n          throw new Error(`Plugin error: hash mismatch. Expected: ${item.hash}. Actual: ${hashAsString()}`);\n        }\n\n        item.name ??= hashAsString();\n      }\n\n      (<any>names[idx]) = item.name ?? String(idx);\n      return module;\n    }),\n  );\n\n  return [names, manifestsWasm];\n}\n", "export async function responseToModule(\n  response: Response,\n  hasHash?: boolean,\n): Promise<{ module: WebAssembly.Module; data?: ArrayBuffer }> {\n  if (String(response.headers.get('Content-Type')).split(';')[0] === 'application/octet-stream') {\n    const headers = new Headers(response.headers);\n    headers.set('Content-Type', 'application/wasm');\n\n    response = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: headers,\n    });\n  }\n\n  // XXX(chrisdickinson): Note that we want to pass a `Response` to WebAssembly.compileStreaming if we\n  // can to play nicely with V8's code caching [1]. At the same time, we need the original ArrayBuffer data\n  // to verify any hashes. There's no way back to bytes from `WebAssembly.Module`, so we have to `.clone()`\n  // the response to get the `ArrayBuffer` data if we need to check a hash.\n  //\n  // [1]: https://v8.dev/blog/wasm-code-caching#algorithm\n  const data = hasHash ? await response.clone().arrayBuffer() : undefined;\n  const module = await WebAssembly.compileStreaming(response);\n\n  return { module, data };\n}\n", "import { CallContext } from './call-context.ts';\n\n/**\n * {@link Plugin} Config\n */\nexport interface PluginConfigLike {\n  [key: string]: string;\n}\n\n/**\n * `PluginOutput` is a view around some memory exposed by the plugin. Typically\n * returned by {@link Plugin#call | `plugin.call()`} or {@link CallContext#read\n * | `callContext.read()`}. It implements the read side of\n * [`DataView`](https://mdn.io/dataview) along with methods for reading string\n * and JSON data out of the backing buffer.\n */\nexport class PluginOutput extends DataView {\n  static #decoder = new TextDecoder();\n  #bytes: Uint8Array | null = null;\n\n  /** @hidden */\n  constructor(buffer: ArrayBufferLike) {\n    super(buffer);\n  }\n\n  json(): any {\n    return JSON.parse(this.string());\n  }\n\n  arrayBuffer(): ArrayBufferLike {\n    return this.buffer;\n  }\n\n  text(): string {\n    return this.string();\n  }\n\n  /** @hidden */\n  string(): string {\n    return PluginOutput.#decoder.decode(this.buffer);\n  }\n\n  bytes(): Uint8Array {\n    this.#bytes ??= new Uint8Array(this.buffer);\n    return this.#bytes;\n  }\n\n  setInt8(_byteOffset: number, _value: number): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setInt16(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setInt32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setUint8(_byteOffset: number, _value: number): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setUint16(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setUint32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setFloat32(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setFloat64(_byteOffset: number, _value: number, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setBigInt64(_byteOffset: number, _value: bigint, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n\n  setBigUint64(_byteOffset: number, _value: bigint, _littleEndian?: boolean): void {\n    throw new Error('Cannot set values on output');\n  }\n}\n\nexport type PluginConfig = Record<string, string>;\n\nexport interface Plugin {\n  /**\n   * Check if a function exists in the WebAssembly module.\n   *\n   * @param {string | [string, string]} funcName The function's name, or a tuple of target module name and function name.\n   * @returns {Promise<boolean>} true if the function exists, otherwise false\n   */\n  functionExists(funcName: string | [string, string]): Promise<boolean>;\n  close(): Promise<void>;\n\n  /**\n   * Call a specific function from the WebAssembly module with provided input.\n   *\n   * @param {string | [string, string]} funcName The name of the function to call\n   * @param {Uint8Array | string} input The input to pass to the function\n   * @returns {Promise<PluginOutput | null>} The result from the function call\n   */\n  call(funcName: string | [string, string], input?: string | number | Uint8Array): Promise<PluginOutput | null>;\n  getExports(name?: string): Promise<WebAssembly.ModuleExportDescriptor[]>;\n  getImports(name?: string): Promise<WebAssembly.ModuleImportDescriptor[]>;\n  getInstance(name?: string): Promise<WebAssembly.Instance>;\n\n  /**\n   * Whether the plugin is currently processing a call.\n   */\n  isActive(): boolean;\n\n  /**\n   * Reset Plugin memory. If called while the plugin is {@link Plugin#isActive|actively executing}, memory will not be reset.\n   *\n   * @returns {Promise<boolean>} Whether or not the reset was successful.\n   */\n  reset(): Promise<boolean>;\n}\n\n/**\n * Options for initializing an Extism plugin.\n */\nexport interface ExtismPluginOptions {\n  /**\n   * Whether or not to enable WASI preview 1.\n   */\n  useWasi?: boolean;\n\n  /**\n   * Whether or not to run the Wasm module in a Worker thread. Requires\n   * {@link Capabilities#hasWorkerCapability | `CAPABILITIES.hasWorkerCapability`} to\n   * be true. Defaults to false.\n   *\n   * This feature is marked experimental as we work out [a bug](https://github.com/extism/js-sdk/issues/46).\n   *\n   * @experimental\n   */\n  runInWorker?: boolean;\n\n  /**\n   * A logger implementation. Must provide `info`, `debug`, `warn`, and `error` methods.\n   */\n  logger?: Console;\n\n  /**\n   * A map of namespaces to function names to host functions.\n   *\n   * ```js\n   * const functions = {\n   *   'my_great_namespace': {\n   *     'my_func': (callContext: CallContext, input: bigint) => {\n   *       const output = callContext.read(input);\n   *       if (output !== null) {\n   *         console.log(output.string());\n   *       }\n   *     }\n   *   }\n   * }\n   * ```\n   */\n  functions?: { [key: string]: { [key: string]: (callContext: CallContext, ...args: any[]) => any } } | undefined;\n  allowedPaths?: { [key: string]: string } | undefined;\n  allowedHosts?: string[] | undefined;\n\n  /**\n   * Whether WASI stdout should be forwarded to the host.\n   *\n   * Overrides the `EXTISM_ENABLE_WASI_OUTPUT` environment variable.\n   */\n  enableWasiOutput?: boolean;\n  config?: PluginConfigLike;\n  fetch?: typeof fetch;\n  sharedArrayBufferSize?: number;\n}\n\nexport interface InternalConfig {\n  logger: Console;\n  allowedHosts: string[];\n  allowedPaths: { [key: string]: string };\n  enableWasiOutput: boolean;\n  functions: { [namespace: string]: { [func: string]: any } };\n  fetch: typeof fetch;\n  wasiEnabled: boolean;\n  config: PluginConfig;\n  sharedArrayBufferSize: number;\n}\n\nexport interface InternalWasi {\n  importObject(): Promise<Record<string, WebAssembly.ImportValue>>;\n  initialize(instance: WebAssembly.Instance): Promise<void>;\n  close(): Promise<void>;\n}\n\n/**\n * Represents the raw bytes of a WASM file loaded into memory\n *\n * @category Manifests\n */\nexport interface ManifestWasmData {\n  data: Uint8Array;\n}\n\n/**\n * Represents a url to a WASM module\n */\nexport interface ManifestWasmUrl {\n  url: URL | string;\n}\n\n/**\n * Represents a path to a WASM module\n */\nexport interface ManifestWasmPath {\n  path: string;\n}\n\n/**\n * Represents a WASM module as a response\n */\nexport interface ManifestWasmResponse {\n  response: Response;\n}\n\n/**\n * Represents a WASM module as a response\n */\nexport interface ManifestWasmModule {\n  module: WebAssembly.Module;\n}\n\n/**\n * The WASM to load as bytes, a path, a fetch `Response`, a `WebAssembly.Module`, or a url\n *\n * @property name The name of the Wasm module. Used when disambiguating {@link Plugin#call | `Plugin#call`} targets when the\n * plugin embeds multiple Wasm modules.\n *\n * @property hash The expected SHA-256 hash of the associated Wasm module data. {@link createPlugin} validates incoming Wasm against\n * provided hashes. If running on Node v18, `node` must be invoked using the `--experimental-global-webcrypto` flag.\n *\n * \u26A0\uFE0F `module` cannot be used in conjunction with `hash`: the Web Platform does not currently provide a way to get source\n * bytes from a `WebAssembly.Module` in order to hash.\n *\n */\nexport type ManifestWasm = (\n  | ManifestWasmUrl\n  | ManifestWasmData\n  | ManifestWasmPath\n  | ManifestWasmResponse\n  | ManifestWasmModule\n) & {\n  name?: string;\n  hash?: string;\n};\n\n/**\n * The manifest which describes the {@link Plugin} code and runtime constraints. This is passed to {@link createPlugin}\n *\n * ```js\n * let manifest = {\n *   wasm: [{name: 'my-wasm', url: 'http://example.com/path/to/wasm'}],\n *   config: {\n *     'greeting': 'hello' // these variables will be available via `extism_get_var` in plugins\n *   }\n * }\n * ```\n *\n * Every member of `.wasm` is expected to be an instance of {@link ManifestWasm}.\n *\n * @see [Extism](https://extism.org/) > [Concepts](https://extism.org/docs/category/concepts) > [Manifest](https://extism.org/docs/concepts/manifest)\n */\nexport interface Manifest {\n  wasm: Array<ManifestWasm>;\n  config?: PluginConfigLike;\n}\n\n/**\n * Any type that can be converted into an Extism {@link Manifest}.\n * - `object` instances that implement {@link Manifest} are validated.\n * - `ArrayBuffer` instances are converted into {@link Manifest}s with a single {@link ManifestUint8Array} member.\n * - `URL` instances are fetched and their responses interpreted according to their `content-type` response header. `application/wasm` and `application/octet-stream` items\n *   are treated as {@link ManifestUint8Array} items; `application/json` and `text/json` are treated as JSON-encoded {@link Manifest}s.\n * - `string` instances that start with `http://`, `https://`, or `file://` are treated as URLs.\n * - `string` instances that start with `{` treated as JSON-encoded {@link Manifest}s.\n * - All other `string` instances are treated as {@link ManifestWasmPath}.\n *\n * ```js\n * let manifest = {\n *   wasm: [{name: 'my-wasm', url: 'http://example.com/path/to/wasm'}],\n *   config: {\n *     'greeting': 'hello' // these variables will be available via `extism_get_var` in plugins\n *   }\n * }\n *\n * let manifest = '{\"wasm\": {\"url\": \"https://example.com\"}}'\n * let manifest = 'path/to/file.wasm'\n * let manifest = new ArrayBuffer()\n * ```\n *\n * @see [Extism](https://extism.org/) > [Concepts](https://extism.org/docs/category/concepts) > [Manifest](https://extism.org/docs/concepts/manifest)\n *\n * @throws {@link TypeError} when `URL` parameters don't resolve to a known `content-type`\n * @throws {@link TypeError} when the resulting {@link Manifest} does not contain a `wasm` member with valid {@link ManifestWasm} items.\n */\nexport type ManifestLike = Manifest | Response | WebAssembly.Module | ArrayBuffer | string | URL;\n\nexport interface Capabilities {\n  /**\n   * Whether or not the environment allows SharedArrayBuffers to be passed to `TextDecoder.decode` and `TextEncoder.encodeInto` directly\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  allowSharedBufferCodec: boolean;\n\n  /**\n   * Whether or not {@link ManifestWasm} items support the \"path:\" key.\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  manifestSupportsPaths: boolean;\n\n  /**\n   * Whether or not cross-origin checks are enforced for outgoing HTTP requests on this platform.\n   *\n   * - \u274C node\n   * - \u274C deno\n   * - \u274C bun\n   * - \u2705 firefox\n   * - \u2705 chrome\n   * - \u2705 webkit\n   */\n  crossOriginChecksEnforced: boolean;\n\n  /**\n   * Whether or not the host environment has access to a filesystem.\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \u274C firefox\n   * - \u274C chrome\n   * - \u274C webkit\n   */\n  fsAccess: boolean;\n\n  /**\n   * Whether or not the host environment supports moving Wasm plugin workloads to a worker. This requires\n   * SharedArrayBuffer support, which requires `window.crossOriginIsolated` to be true in browsers.\n   *\n   * @see [`crossOriginalIsolated` on MDN](https://mdn.io/crossOriginIsolated)\n   *\n   * - \u2705 node\n   * - \u2705 deno\n   * - \u2705 bun\n   * - \uD83D\uDD12 firefox\n   * - \uD83D\uDD12 chrome\n   * - \uD83D\uDD12 webkit\n   */\n  hasWorkerCapability: boolean;\n\n  /**\n   * Whether or not the host environment supports WASI preview 1.\n   *\n   * @see [`WASI`](https://wasi.dev/) and [`WASI Preview 1`](https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md)\n   *\n   * - \u2705 node (via [`node:wasi`](https://nodejs.org/api/wasi.html))\n   * - \u2705 deno (via [`deno.land/std/wasi/snapshot_preview1`](https://deno.land/std@0.200.0/wasi/snapshot_preview1.ts))\n   * - \u274C bun\n   * - \u2705 firefox (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   * - \u2705 chrome (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   * - \u2705 webkit (via [`@bjorn3/browser_wasi_shim`](https://www.npmjs.com/package/@bjorn3/browser_wasi_shim))\n   */\n  supportsWasiPreview1: boolean;\n\n  /**\n   * Whether or not the `EXTISM_ENABLE_WASI_OUTPUT` environment variable has been set.\n   *\n   * This value is consulted whenever {@link ExtismPluginOptions#enableWasiOutput} is omitted.\n   */\n  extismStdoutEnvVarSet: boolean;\n}\n", "import { type PluginConfig, PluginOutput } from './interfaces.ts';\nimport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nexport const BEGIN = Symbol('begin');\nexport const END = Symbol('end');\nexport const ENV = Symbol('env');\nexport const GET_BLOCK = Symbol('get-block');\nexport const IMPORT_STATE = Symbol('import-state');\nexport const EXPORT_STATE = Symbol('export-state');\nexport const STORE = Symbol('store-value');\nexport const RESET = Symbol('reset');\n\nexport class Block {\n  buffer: ArrayBufferLike;\n  view: DataView;\n  local: boolean;\n\n  get byteLength() {\n    return this.buffer.byteLength;\n  }\n\n  constructor(arrayBuffer: ArrayBufferLike, local: boolean) {\n    this.buffer = arrayBuffer;\n    this.view = new DataView(this.buffer);\n    this.local = local;\n  }\n\n  static indexToAddress(idx: bigint | number): bigint {\n    return BigInt(idx) << 48n;\n  }\n\n  static addressToIndex(addr: bigint | number): number {\n    return Number(BigInt(addr) >> 48n);\n  }\n\n  static maskAddress(addr: bigint | number): number {\n    return Number(BigInt(addr) & ((1n << 48n) - 1n));\n  }\n}\n\nexport type CallState = {\n  blocks: [ArrayBufferLike | null, number][];\n  stack: [number | null, number | null, number | null][];\n};\n\nexport class CallContext {\n  #stack: [number | null, number | null, number | null][];\n  #blocks: (Block | null)[] = [];\n  #logger: Console;\n  #decoder: TextDecoder;\n  #encoder: TextEncoder;\n  #arrayBufferType: { new (size: number): ArrayBufferLike };\n  #config: PluginConfig;\n  #vars: Map<string, number> = new Map();\n\n  /** @hidden */\n  constructor(type: { new (size: number): ArrayBufferLike }, logger: Console, config: PluginConfig) {\n    this.#arrayBufferType = type;\n    this.#logger = logger;\n    this.#decoder = new TextDecoder();\n    this.#encoder = new TextEncoder();\n\n    this.#stack = [];\n\n    // reserve the null page.\n    this.alloc(1);\n\n    this.#config = config;\n  }\n\n  /**\n   * Allocate a chunk of host memory visible to plugins via other extism host functions.\n   * Returns the start address of the block.\n   */\n  alloc(size: bigint | number): bigint {\n    const block = new Block(new this.#arrayBufferType(Number(size)), true);\n    const index = this.#blocks.length;\n    this.#blocks.push(block);\n    return Block.indexToAddress(index);\n  }\n\n  /**\n   * Read a variable from extism memory by name.\n   *\n   * @returns {@link PluginOutput}\n   */\n  getVariable(name: string): PluginOutput | null {\n    if (!this.#vars.has(name)) {\n      return null;\n    }\n    return this.read(this.#vars.get(name) as number);\n  }\n\n  /**\n   * Set a variable to a given string or byte array value. Returns the start\n   * address of the variable. The start address is reused when changing the\n   * value of an existing variable.\n   *\n   * @returns bigint\n   */\n  setVariable(name: string, value: string | Uint8Array): bigint {\n    const newIdx = this[STORE](value);\n    if (newIdx === null) {\n      return 0n;\n    }\n\n    // Re-use the old address mapping.\n    const oldIdx = this.#vars.get(name) ?? null;\n    if (oldIdx !== null) {\n      this.#blocks[oldIdx] = this.#blocks[newIdx];\n      this.#blocks[newIdx] = null;\n      if (newIdx === this.#blocks.length - 1) {\n        this.#blocks.pop();\n      }\n    }\n\n    this.#vars.set(name, oldIdx ?? newIdx);\n    return Block.indexToAddress(oldIdx ?? newIdx);\n  }\n\n  /**\n   * Given an address in extism memory, return a {@link PluginOutput} that represents\n   * a view of that memory. Returns null if the address is invalid.\n   *\n   * @returns bigint\n   */\n  read(addr: bigint | number): PluginOutput | null {\n    const blockIdx = Block.addressToIndex(addr);\n    const block = this.#blocks[blockIdx];\n    if (!block) {\n      return null;\n    }\n\n    const buffer =\n      !(block.buffer instanceof ArrayBuffer) && !CAPABILITIES.allowSharedBufferCodec\n        ? new Uint8Array(block.buffer).slice().buffer\n        : block.buffer;\n\n    return new PluginOutput(buffer);\n  }\n\n  /**\n   * Store a string or Uint8Array value in extism memory.\n   *\n   * @returns bigint\n   */\n  store(input: string | Uint8Array): bigint {\n    const idx = this[STORE](input);\n    if (!idx) {\n      throw new Error('failed to store output');\n    }\n    return Block.indexToAddress(idx);\n  }\n\n  length(addr: bigint): bigint {\n    const blockIdx = Block.addressToIndex(addr);\n    const block = this.#blocks[blockIdx];\n    if (!block) {\n      return 0n;\n    }\n    return BigInt(block.buffer.byteLength);\n  }\n\n  /** @hidden */\n  [ENV] = {\n    alloc: (n: bigint): bigint => {\n      return this.alloc(n);\n    },\n\n    free: (addr: number) => {\n      this.#blocks[Block.addressToIndex(addr)] = null;\n    },\n\n    load_u8: (addr: bigint): number => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      return block?.view.getUint8(Number(offset)) as number;\n    },\n\n    load_u64: (addr: bigint): bigint => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      return block?.view.getBigUint64(Number(offset), true) as bigint;\n    },\n\n    store_u8: (addr: bigint, n: number) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      block?.view.setUint8(Number(offset), Number(n));\n    },\n\n    store_u64: (addr: bigint, n: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const offset = Block.maskAddress(addr);\n      const block = this.#blocks[blockIdx];\n      block?.view.setBigUint64(Number(offset), n, true);\n    },\n\n    input_offset: () => {\n      const blockIdx = this.#stack[this.#stack.length - 1][0];\n      return Block.indexToAddress(blockIdx || 0);\n    },\n\n    input_length: () => {\n      return BigInt(this.#input?.byteLength ?? 0);\n    },\n\n    input_load_u8: (addr: bigint): number => {\n      const offset = Block.maskAddress(addr);\n      return this.#input?.view.getUint8(Number(offset)) as number;\n    },\n\n    input_load_u64: (addr: bigint): bigint => {\n      const offset = Block.maskAddress(addr);\n      return this.#input?.view.getBigUint64(Number(offset), true) as bigint;\n    },\n\n    output_set: (addr: bigint, length: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        throw new Error(`cannot assign to this block (addr=${addr.toString(16).padStart(16, '0')}; length=${length})`);\n      }\n\n      if (length > block.buffer.byteLength) {\n        throw new Error('length longer than target block');\n      }\n\n      this.#stack[this.#stack.length - 1][1] = blockIdx;\n    },\n\n    error_set: (addr: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        throw new Error('cannot assign to this block');\n      }\n\n      this.#stack[this.#stack.length - 1][2] = blockIdx;\n    },\n\n    config_get: (addr: bigint): bigint => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        return 0n;\n      }\n\n      const key = item.string();\n\n      if (key in this.#config) {\n        return this.store(this.#config[key]);\n      }\n\n      return 0n;\n    },\n\n    var_get: (addr: bigint): bigint => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        return 0n;\n      }\n\n      const key = item.string();\n      return this.#vars.has(key) ? Block.indexToAddress(this.#vars.get(key) as number) : 0n;\n    },\n\n    var_set: (addr: bigint, valueaddr: bigint) => {\n      const item = this.read(addr);\n\n      if (item === null) {\n        return 0n;\n      }\n\n      const key = item.string();\n      if (valueaddr === 0n) {\n        this.#vars.delete(key);\n        return 0n;\n      }\n\n      this.#vars.set(key, Block.addressToIndex(valueaddr));\n    },\n\n    http_request: (_requestOffset: bigint, _bodyOffset: bigint): bigint => {\n      this.#logger.error('http_request is not enabled');\n      return 0n;\n    },\n\n    http_status_code: (): number => {\n      this.#logger.error('http_status_code is not enabled');\n      return 0;\n    },\n\n    length: (addr: bigint): bigint => {\n      return this.length(addr);\n    },\n\n    length_unsafe: (addr: bigint): bigint => {\n      return this.length(addr);\n    },\n\n    log_warn: (addr: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        return this.#logger.error(\n          `failed to log(warn): bad block reference in addr 0x${addr.toString(16).padStart(64, '0')}`,\n        );\n      }\n      const text = this.#decoder.decode(block.buffer);\n      this.#logger.warn(text);\n    },\n\n    log_info: (addr: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        return this.#logger.error(\n          `failed to log(info): bad block reference in addr 0x${addr.toString(16).padStart(64, '0')}`,\n        );\n      }\n      const text = this.#decoder.decode(block.buffer);\n      this.#logger.info(text);\n    },\n\n    log_debug: (addr: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        return this.#logger.error(\n          `failed to log(debug): bad block reference in addr 0x${addr.toString(16).padStart(64, '0')}`,\n        );\n      }\n      const text = this.#decoder.decode(block.buffer);\n      this.#logger.debug(text);\n    },\n\n    log_error: (addr: bigint) => {\n      const blockIdx = Block.addressToIndex(addr);\n      const block = this.#blocks[blockIdx];\n      if (!block) {\n        return this.#logger.error(\n          `failed to log(error): bad block reference in addr 0x${addr.toString(16).padStart(64, '0')}`,\n        );\n      }\n      const text = this.#decoder.decode(block.buffer);\n      this.#logger.error(text);\n    },\n  };\n\n  /** @hidden */\n  get #input(): Block | null {\n    const idx = this.#stack[this.#stack.length - 1][0];\n    if (idx === null) {\n      return null;\n    }\n    return this.#blocks[idx];\n  }\n\n  /** @hidden */\n  [RESET]() {\n    // preserve the null page.\n    this.#blocks.length = 1;\n\n    // ... but dump the stack items.\n    this.#stack.length = 0;\n  }\n\n  /** @hidden */\n  [GET_BLOCK](index: number): Block {\n    const block = this.#blocks[index];\n    if (!block) {\n      throw new Error(`invalid block index: ${index}`);\n    }\n    return block;\n  }\n\n  /** @hidden */\n  [IMPORT_STATE](state: CallState, copy: boolean = false) {\n    // eslint-disable-next-line prefer-const\n    for (let [buf, idx] of state.blocks) {\n      if (buf && copy) {\n        const dst = new Uint8Array(new this.#arrayBufferType(Number(buf.byteLength)));\n        dst.set(new Uint8Array(buf));\n        buf = dst.buffer;\n      }\n      this.#blocks[idx] = buf ? new Block(buf, false) : null;\n    }\n    this.#stack = state.stack;\n  }\n\n  /** @hidden */\n  [EXPORT_STATE](): CallState {\n    return {\n      stack: this.#stack.slice(),\n      blocks: this.#blocks\n        .map((block, idx) => {\n          if (!block) {\n            return [null, idx];\n          }\n\n          if (block.local) {\n            block.local = false;\n            return [block.buffer, idx];\n          }\n          return null;\n        })\n        .filter(Boolean) as [ArrayBufferLike, number][],\n    };\n  }\n\n  /** @hidden */\n  [STORE](input?: string | Uint8Array) {\n    if (!input) {\n      return null;\n    }\n\n    if (typeof input === 'string') {\n      input = this.#encoder.encode(input);\n    }\n\n    if (input instanceof Uint8Array) {\n      if (input.buffer.constructor === this.#arrayBufferType) {\n        // no action necessary, wrap it up in a block\n        const idx = this.#blocks.length;\n        this.#blocks.push(new Block(input.buffer, true));\n        return idx;\n      }\n      const idx = Block.addressToIndex(this.alloc(input.length));\n      const block = this.#blocks[idx] as Block;\n      const buf = new Uint8Array(block.buffer);\n      buf.set(input, 0);\n      return idx;\n    }\n\n    return input;\n  }\n\n  /** @hidden */\n  [BEGIN](input: number | null) {\n    this.#stack.push([input, null, null]);\n  }\n\n  /** @hidden */\n  [END](): [number | null, number | null] {\n    const [, outputIdx, errorIdx] = this.#stack.pop() as (number | null)[];\n    const outputPosition = errorIdx === null ? 1 : 0;\n    const idx = errorIdx ?? outputIdx;\n    const result: [number | null, number | null] = [null, null];\n\n    if (idx === null) {\n      return result;\n    }\n\n    const block = this.#blocks[idx];\n\n    if (block === null) {\n      // TODO: this might be an error? we got an output idx but it referred to a freed (or non-existant) block\n      return result;\n    }\n\n    result[outputPosition] = idx;\n\n    return result;\n  }\n}\n", "import { WASI } from 'wasi';\nimport { type InternalWasi } from '../interfaces.ts';\nimport { devNull } from 'node:os';\nimport { open } from 'node:fs/promises';\nimport { closeSync } from 'node:fs';\n\nasync function createDevNullFDs() {\n  const [stdin, stdout] = await Promise.all([open(devNull, 'r'), open(devNull, 'w')]);\n  let needsClose = true;\n  // TODO: make this check always run when bun fixes [1], so `fs.promises.open()` returns a `FileHandle` as expected.\n  // [1]: https://github.com/oven-sh/bun/issues/5918\n  let close = async () => {\n    closeSync(stdin as any);\n    closeSync(stdout as any);\n  };\n  if (typeof stdin !== 'number') {\n    const fr = new globalThis.FinalizationRegistry((held: number) => {\n      try {\n        if (needsClose) closeSync(held);\n      } catch {\n        // The fd may already be closed.\n      }\n    });\n\n    fr.register(stdin, stdin.fd);\n    fr.register(stdout, stdout.fd);\n    close = async () => {\n      needsClose = false;\n      await Promise.all([stdin.close(), stdout.close()]).catch(() => {});\n    };\n  }\n\n  return {\n    close,\n    fds: [stdin.fd, stdout.fd, stdout.fd],\n  };\n}\n\nexport async function loadWasi(\n  allowedPaths: { [from: string]: string },\n  enableWasiOutput: boolean,\n): Promise<InternalWasi> {\n  const {\n    close,\n    fds: [stdin, stdout, stderr],\n  } = enableWasiOutput ? { async close() {}, fds: [0, 1, 2] } : await createDevNullFDs();\n\n  const context = new WASI({\n    version: 'preview1',\n    preopens: allowedPaths,\n    stdin,\n    stdout,\n    stderr,\n  } as any);\n\n  return {\n    async importObject() {\n      return context.wasiImport;\n    },\n\n    async close() {\n      await close();\n    },\n\n    async initialize(instance: WebAssembly.Instance) {\n      const memory = instance.exports.memory as WebAssembly.Memory;\n\n      if (!memory) {\n        throw new Error('The module has to export a default memory.');\n      }\n\n      if (instance.exports._initialize) {\n        const init = instance.exports._initialize as CallableFunction;\n        if (context.initialize) {\n          context.initialize({\n            exports: {\n              memory,\n              _initialize: () => {\n                init();\n              },\n            },\n          });\n        } else {\n          init();\n        }\n      } else {\n        context.start({\n          exports: {\n            memory,\n            _start: () => {},\n          },\n        });\n      }\n    },\n  };\n}\n", "import { CallContext, RESET, GET_BLOCK, BEGIN, END, ENV, STORE } from './call-context.ts';\nimport { PluginOutput, type InternalConfig, InternalWasi } from './interfaces.ts';\nimport { loadWasi } from './polyfills/deno-wasi.ts';\n\nexport const EXTISM_ENV = 'extism:host/env';\n\ntype InstantiatedModule = { guestType: string; module: WebAssembly.Module; instance: WebAssembly.Instance };\n\nexport class ForegroundPlugin {\n  #context: CallContext;\n  #modules: InstantiatedModule[];\n  #names: string[];\n  #active: boolean = false;\n  #wasi: InternalWasi | null;\n\n  constructor(context: CallContext, names: string[], modules: InstantiatedModule[], wasi: InternalWasi | null) {\n    this.#context = context;\n    this.#names = names;\n    this.#modules = modules;\n    this.#wasi = wasi;\n  }\n\n  async reset(): Promise<boolean> {\n    if (this.isActive()) {\n      return false;\n    }\n\n    this.#context[RESET]();\n    return true;\n  }\n\n  isActive() {\n    return this.#active;\n  }\n\n  async functionExists(funcName: string | [string, string]): Promise<boolean> {\n    try {\n      const search: string[] = [].concat(<any>funcName);\n      const [target, name] =\n        search.length === 2\n          ? [this.lookupTarget(search[0]), search[1]]\n          : [\n              this.#modules.find((guest) => {\n                const exports = WebAssembly.Module.exports(guest.module);\n                return exports.find((item) => {\n                  return item.name === search[0] && item.kind === 'function';\n                });\n              }),\n              search[0],\n            ];\n\n      if (!target) {\n        return false;\n      }\n\n      const func = target.instance.exports[name] as any;\n\n      if (!func) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      // lookupTarget will throw if it cannot find the specified target; cast it into a boolean\n      return false;\n    }\n  }\n\n  async callBlock(funcName: string | [string, string], input: number | null): Promise<[number | null, number | null]> {\n    this.#active = true;\n    const search: string[] = [].concat(<any>funcName);\n    const [target, name] =\n      search.length === 2\n        ? [this.lookupTarget(search[0]), search[1]]\n        : [\n            this.#modules.find((guest) => {\n              const exports = WebAssembly.Module.exports(guest.module);\n              return exports.find((item) => {\n                return item.name === search[0] && item.kind === 'function';\n              });\n            }),\n            search[0],\n          ];\n\n    if (!target) {\n      throw Error(`Plugin error: target \"${search.join('\" \"')}\" does not exist`);\n    }\n    const func = target.instance.exports[name] as any;\n    if (!func) {\n      throw Error(`Plugin error: function \"${search.join('\" \"')}\" does not exist`);\n    }\n\n    this.#context[BEGIN](input ?? null);\n    try {\n      func();\n      return this.#context[END]();\n    } catch (err) {\n      this.#context[END]();\n      throw err;\n    } finally {\n      this.#active = false;\n    }\n  }\n\n  async call(funcName: string | [string, string], input?: string | Uint8Array): Promise<PluginOutput | null> {\n    const inputIdx = this.#context[STORE](input);\n    const [errorIdx, outputIdx] = await this.callBlock(funcName, inputIdx);\n    const shouldThrow = errorIdx !== null;\n    const idx = errorIdx ?? outputIdx;\n\n    if (idx === null) {\n      return null;\n    }\n\n    const block = this.#context[GET_BLOCK](idx);\n    if (!block) {\n      return null;\n    }\n\n    const output = new PluginOutput(block.buffer);\n    if (shouldThrow) {\n      throw new Error(`Plugin-originated error: ${output.string()}`);\n    }\n    return output;\n  }\n\n  private lookupTarget(name: any): InstantiatedModule {\n    const target = String(name ?? '0');\n    const idx = this.#names.findIndex((xs) => xs === target);\n    if (idx === -1) {\n      throw new Error(`no module named \"${name}\"`);\n    }\n    return this.#modules[idx];\n  }\n\n  async getExports(name?: string): Promise<WebAssembly.ModuleExportDescriptor[]> {\n    return WebAssembly.Module.exports(this.lookupTarget(name).module) || [];\n  }\n\n  async getImports(name?: string): Promise<WebAssembly.ModuleImportDescriptor[]> {\n    return WebAssembly.Module.imports(this.lookupTarget(name).module) || [];\n  }\n\n  async getInstance(name?: string): Promise<WebAssembly.Instance> {\n    return this.lookupTarget(name).instance;\n  }\n\n  async close(): Promise<void> {\n    if (this.#wasi) {\n      await this.#wasi.close();\n      this.#wasi = null;\n    }\n  }\n}\n\nexport async function createForegroundPlugin(\n  opts: InternalConfig,\n  names: string[],\n  modules: WebAssembly.Module[],\n  context: CallContext = new CallContext(ArrayBuffer, opts.logger, opts.config),\n): Promise<ForegroundPlugin> {\n  const wasi = opts.wasiEnabled ? await loadWasi(opts.allowedPaths, opts.enableWasiOutput) : null;\n\n  const imports: Record<string, Record<string, any>> = {\n    ...(wasi ? { wasi_snapshot_preview1: await wasi.importObject() } : {}),\n    [EXTISM_ENV]: context[ENV],\n    env: {},\n  };\n\n  for (const namespace in opts.functions) {\n    imports[namespace] = imports[namespace] || {};\n    for (const func in opts.functions[namespace]) {\n      imports[namespace][func] = opts.functions[namespace][func].bind(null, context);\n    }\n  }\n\n  const instances = await Promise.all(\n    modules.map(async (module) => {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (wasi) {\n        await wasi?.initialize(instance);\n      }\n\n      const guestType = instance.exports.hs_init\n        ? 'haskell'\n        : instance.exports._initialize\n        ? 'reactor'\n        : instance.exports._start\n        ? 'command'\n        : 'none';\n\n      const initRuntime: any = instance.exports.hs_init ? instance.exports.hs_init : () => {};\n      initRuntime();\n\n      return { module, instance, guestType };\n    }),\n  );\n\n  return new ForegroundPlugin(context, names, instances, wasi);\n}\n", "export const WORKER_URL = new URL(\"data:text/javascript;base64,dmFyIFU9KGksdCxlKT0+e2lmKCF0LmhhcyhpKSl0aHJvdyBUeXBlRXJyb3IoIkNhbm5vdCAiK2UpfTt2YXIgeD0oaSx0LGUpPT4oVShpLHQsInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkIiksZT9lLmNhbGwoaSk6dC5nZXQoaSkpLFM9KGksdCxlKT0+e2lmKHQuaGFzKGkpKXRocm93IFR5cGVFcnJvcigiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZSIpO3QgaW5zdGFuY2VvZiBXZWFrU2V0P3QuYWRkKGkpOnQuc2V0KGksZSl9LEQ9KGksdCxlLG4pPT4oVShpLHQsIndyaXRlIHRvIHByaXZhdGUgZmllbGQiKSxuP24uY2FsbChpLGUpOnQuc2V0KGksZSksZSk7aW1wb3J0e3BhcmVudFBvcnQgYXMgR31mcm9tIm5vZGU6d29ya2VyX3RocmVhZHMiO3ZhciBBLHAsVD1jbGFzcyBleHRlbmRzIERhdGFWaWV3e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO1ModGhpcyxwLG51bGwpfWpzb24oKXtyZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnN0cmluZygpKX1hcnJheUJ1ZmZlcigpe3JldHVybiB0aGlzLmJ1ZmZlcn10ZXh0KCl7cmV0dXJuIHRoaXMuc3RyaW5nKCl9c3RyaW5nKCl7cmV0dXJuIHgoVCxBKS5kZWNvZGUodGhpcy5idWZmZXIpfWJ5dGVzKCl7cmV0dXJuIHgodGhpcyxwKT8/RCh0aGlzLHAsbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKSx4KHRoaXMscCl9c2V0SW50OChlLG4pe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0SW50MTYoZSxuLHIpe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0SW50MzIoZSxuLHIpe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0VWludDgoZSxuKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldFVpbnQxNihlLG4scil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX1zZXRVaW50MzIoZSxuLHIpe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCB2YWx1ZXMgb24gb3V0cHV0Iil9c2V0RmxvYXQzMihlLG4scil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX1zZXRGbG9hdDY0KGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldEJpZ0ludDY0KGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgdmFsdWVzIG9uIG91dHB1dCIpfXNldEJpZ1VpbnQ2NChlLG4scil7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IHZhbHVlcyBvbiBvdXRwdXQiKX19LGI9VDtBPW5ldyBXZWFrTWFwLHA9bmV3IFdlYWtNYXAsUyhiLEEsbmV3IFRleHREZWNvZGVyKTt2YXIgRj17YWxsb3dTaGFyZWRCdWZmZXJDb2RlYzohMSxtYW5pZmVzdFN1cHBvcnRzUGF0aHM6ITAsY3Jvc3NPcmlnaW5DaGVja3NFbmZvcmNlZDohMSxmc0FjY2VzczohMCxoYXNXb3JrZXJDYXBhYmlsaXR5OiEwLHN1cHBvcnRzV2FzaVByZXZpZXcxOiEwLGV4dGlzbVN0ZG91dEVudlZhclNldDpCb29sZWFuKHByb2Nlc3MuZW52LkVYVElTTV9FTkFCTEVfV0FTSV9PVVRQVVQpfTt2YXIgQj1TeW1ib2woImJlZ2luIiksaz1TeW1ib2woImVuZCIpLHY9U3ltYm9sKCJlbnYiKSxDPVN5bWJvbCgiZ2V0LWJsb2NrIiksST1TeW1ib2woImltcG9ydC1zdGF0ZSIpLEU9U3ltYm9sKCJleHBvcnQtc3RhdGUiKSx5PVN5bWJvbCgic3RvcmUtdmFsdWUiKSxQPVN5bWJvbCgicmVzZXQiKSxhPWNsYXNze2dldCBieXRlTGVuZ3RoKCl7cmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGh9Y29uc3RydWN0b3IodCxlKXt0aGlzLmJ1ZmZlcj10LHRoaXMudmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpLHRoaXMubG9jYWw9ZX1zdGF0aWMgaW5kZXhUb0FkZHJlc3ModCl7cmV0dXJuIEJpZ0ludCh0KTw8NDhufXN0YXRpYyBhZGRyZXNzVG9JbmRleCh0KXtyZXR1cm4gTnVtYmVyKEJpZ0ludCh0KT4+NDhuKX1zdGF0aWMgbWFza0FkZHJlc3ModCl7cmV0dXJuIE51bWJlcihCaWdJbnQodCkmKDFuPDw0OG4pLTFuKX19LFIsZD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy4jdD1bXTt0aGlzLiNzPW5ldyBNYXA7dGhpc1tSXT17YWxsb2M6dD0+dGhpcy5hbGxvYyh0KSxmcmVlOnQ9Pnt0aGlzLiN0W2EuYWRkcmVzc1RvSW5kZXgodCldPW51bGx9LGxvYWRfdTg6dD0+e2xldCBlPWEuYWRkcmVzc1RvSW5kZXgodCksbj1hLm1hc2tBZGRyZXNzKHQpO3JldHVybiB0aGlzLiN0W2VdPy52aWV3LmdldFVpbnQ4KE51bWJlcihuKSl9LGxvYWRfdTY0OnQ9PntsZXQgZT1hLmFkZHJlc3NUb0luZGV4KHQpLG49YS5tYXNrQWRkcmVzcyh0KTtyZXR1cm4gdGhpcy4jdFtlXT8udmlldy5nZXRCaWdVaW50NjQoTnVtYmVyKG4pLCEwKX0sc3RvcmVfdTg6KHQsZSk9PntsZXQgbj1hLmFkZHJlc3NUb0luZGV4KHQpLHI9YS5tYXNrQWRkcmVzcyh0KTt0aGlzLiN0W25dPy52aWV3LnNldFVpbnQ4KE51bWJlcihyKSxOdW1iZXIoZSkpfSxzdG9yZV91NjQ6KHQsZSk9PntsZXQgbj1hLmFkZHJlc3NUb0luZGV4KHQpLHI9YS5tYXNrQWRkcmVzcyh0KTt0aGlzLiN0W25dPy52aWV3LnNldEJpZ1VpbnQ2NChOdW1iZXIociksZSwhMCl9LGlucHV0X29mZnNldDooKT0+e2xldCB0PXRoaXMuI2VbdGhpcy4jZS5sZW5ndGgtMV1bMF07cmV0dXJuIGEuaW5kZXhUb0FkZHJlc3ModHx8MCl9LGlucHV0X2xlbmd0aDooKT0+QmlnSW50KHRoaXMuI2w/LmJ5dGVMZW5ndGg/PzApLGlucHV0X2xvYWRfdTg6dD0+e2xldCBlPWEubWFza0FkZHJlc3ModCk7cmV0dXJuIHRoaXMuI2w/LnZpZXcuZ2V0VWludDgoTnVtYmVyKGUpKX0saW5wdXRfbG9hZF91NjQ6dD0+e2xldCBlPWEubWFza0FkZHJlc3ModCk7cmV0dXJuIHRoaXMuI2w/LnZpZXcuZ2V0QmlnVWludDY0KE51bWJlcihlKSwhMCl9LG91dHB1dF9zZXQ6KHQsZSk9PntsZXQgbj1hLmFkZHJlc3NUb0luZGV4KHQpLHI9dGhpcy4jdFtuXTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBhc3NpZ24gdG8gdGhpcyBibG9jayAoYWRkcj0ke3QudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCIwIil9OyBsZW5ndGg9JHtlfSlgKTtpZihlPnIuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJsZW5ndGggbG9uZ2VyIHRoYW4gdGFyZ2V0IGJsb2NrIik7dGhpcy4jZVt0aGlzLiNlLmxlbmd0aC0xXVsxXT1ufSxlcnJvcl9zZXQ6dD0+e2xldCBlPWEuYWRkcmVzc1RvSW5kZXgodCk7aWYoIXRoaXMuI3RbZV0pdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYXNzaWduIHRvIHRoaXMgYmxvY2siKTt0aGlzLiNlW3RoaXMuI2UubGVuZ3RoLTFdWzJdPWV9LGNvbmZpZ19nZXQ6dD0+e2xldCBlPXRoaXMucmVhZCh0KTtpZihlPT09bnVsbClyZXR1cm4gMG47bGV0IG49ZS5zdHJpbmcoKTtyZXR1cm4gbiBpbiB0aGlzLiNhP3RoaXMuc3RvcmUodGhpcy4jYVtuXSk6MG59LHZhcl9nZXQ6dD0+e2xldCBlPXRoaXMucmVhZCh0KTtpZihlPT09bnVsbClyZXR1cm4gMG47bGV0IG49ZS5zdHJpbmcoKTtyZXR1cm4gdGhpcy4jcy5oYXMobik/YS5pbmRleFRvQWRkcmVzcyh0aGlzLiNzLmdldChuKSk6MG59LHZhcl9zZXQ6KHQsZSk9PntsZXQgbj10aGlzLnJlYWQodCk7aWYobj09PW51bGwpcmV0dXJuIDBuO2xldCByPW4uc3RyaW5nKCk7aWYoZT09PTBuKXJldHVybiB0aGlzLiNzLmRlbGV0ZShyKSwwbjt0aGlzLiNzLnNldChyLGEuYWRkcmVzc1RvSW5kZXgoZSkpfSxodHRwX3JlcXVlc3Q6KHQsZSk9Pih0aGlzLiNuLmVycm9yKCJodHRwX3JlcXVlc3QgaXMgbm90IGVuYWJsZWQiKSwwbiksaHR0cF9zdGF0dXNfY29kZTooKT0+KHRoaXMuI24uZXJyb3IoImh0dHBfc3RhdHVzX2NvZGUgaXMgbm90IGVuYWJsZWQiKSwwKSxsZW5ndGg6dD0+dGhpcy5sZW5ndGgodCksbGVuZ3RoX3Vuc2FmZTp0PT50aGlzLmxlbmd0aCh0KSxsb2dfd2Fybjp0PT57bGV0IGU9YS5hZGRyZXNzVG9JbmRleCh0KSxuPXRoaXMuI3RbZV07aWYoIW4pcmV0dXJuIHRoaXMuI24uZXJyb3IoYGZhaWxlZCB0byBsb2cod2Fybik6IGJhZCBibG9jayByZWZlcmVuY2UgaW4gYWRkciAweCR7dC50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIjAiKX1gKTtsZXQgcj10aGlzLiNyLmRlY29kZShuLmJ1ZmZlcik7dGhpcy4jbi53YXJuKHIpfSxsb2dfaW5mbzp0PT57bGV0IGU9YS5hZGRyZXNzVG9JbmRleCh0KSxuPXRoaXMuI3RbZV07aWYoIW4pcmV0dXJuIHRoaXMuI24uZXJyb3IoYGZhaWxlZCB0byBsb2coaW5mbyk6IGJhZCBibG9jayByZWZlcmVuY2UgaW4gYWRkciAweCR7dC50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIjAiKX1gKTtsZXQgcj10aGlzLiNyLmRlY29kZShuLmJ1ZmZlcik7dGhpcy4jbi5pbmZvKHIpfSxsb2dfZGVidWc6dD0+e2xldCBlPWEuYWRkcmVzc1RvSW5kZXgodCksbj10aGlzLiN0W2VdO2lmKCFuKXJldHVybiB0aGlzLiNuLmVycm9yKGBmYWlsZWQgdG8gbG9nKGRlYnVnKTogYmFkIGJsb2NrIHJlZmVyZW5jZSBpbiBhZGRyIDB4JHt0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwiMCIpfWApO2xldCByPXRoaXMuI3IuZGVjb2RlKG4uYnVmZmVyKTt0aGlzLiNuLmRlYnVnKHIpfSxsb2dfZXJyb3I6dD0+e2xldCBlPWEuYWRkcmVzc1RvSW5kZXgodCksbj10aGlzLiN0W2VdO2lmKCFuKXJldHVybiB0aGlzLiNuLmVycm9yKGBmYWlsZWQgdG8gbG9nKGVycm9yKTogYmFkIGJsb2NrIHJlZmVyZW5jZSBpbiBhZGRyIDB4JHt0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwiMCIpfWApO2xldCByPXRoaXMuI3IuZGVjb2RlKG4uYnVmZmVyKTt0aGlzLiNuLmVycm9yKHIpfX07dGhpcy4jbz10LHRoaXMuI249ZSx0aGlzLiNyPW5ldyBUZXh0RGVjb2Rlcix0aGlzLiNpPW5ldyBUZXh0RW5jb2Rlcix0aGlzLiNlPVtdLHRoaXMuYWxsb2MoMSksdGhpcy4jYT1ufSNlOyN0OyNuOyNyOyNpOyNvOyNhOyNzO2FsbG9jKHQpe2xldCBlPW5ldyBhKG5ldyB0aGlzLiNvKE51bWJlcih0KSksITApLG49dGhpcy4jdC5sZW5ndGg7cmV0dXJuIHRoaXMuI3QucHVzaChlKSxhLmluZGV4VG9BZGRyZXNzKG4pfWdldFZhcmlhYmxlKHQpe3JldHVybiB0aGlzLiNzLmhhcyh0KT90aGlzLnJlYWQodGhpcy4jcy5nZXQodCkpOm51bGx9c2V0VmFyaWFibGUodCxlKXtsZXQgbj10aGlzW3ldKGUpO2lmKG49PT1udWxsKXJldHVybiAwbjtsZXQgcj10aGlzLiNzLmdldCh0KT8/bnVsbDtyZXR1cm4gciE9PW51bGwmJih0aGlzLiN0W3JdPXRoaXMuI3Rbbl0sdGhpcy4jdFtuXT1udWxsLG49PT10aGlzLiN0Lmxlbmd0aC0xJiZ0aGlzLiN0LnBvcCgpKSx0aGlzLiNzLnNldCh0LHI/P24pLGEuaW5kZXhUb0FkZHJlc3Mocj8/bil9cmVhZCh0KXtsZXQgZT1hLmFkZHJlc3NUb0luZGV4KHQpLG49dGhpcy4jdFtlXTtpZighbilyZXR1cm4gbnVsbDtsZXQgcj0hKG4uYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpJiYhRi5hbGxvd1NoYXJlZEJ1ZmZlckNvZGVjP25ldyBVaW50OEFycmF5KG4uYnVmZmVyKS5zbGljZSgpLmJ1ZmZlcjpuLmJ1ZmZlcjtyZXR1cm4gbmV3IGIocil9c3RvcmUodCl7bGV0IGU9dGhpc1t5XSh0KTtpZighZSl0aHJvdyBuZXcgRXJyb3IoImZhaWxlZCB0byBzdG9yZSBvdXRwdXQiKTtyZXR1cm4gYS5pbmRleFRvQWRkcmVzcyhlKX1sZW5ndGgodCl7bGV0IGU9YS5hZGRyZXNzVG9JbmRleCh0KSxuPXRoaXMuI3RbZV07cmV0dXJuIG4/QmlnSW50KG4uYnVmZmVyLmJ5dGVMZW5ndGgpOjBufWdldCNsKCl7bGV0IHQ9dGhpcy4jZVt0aGlzLiNlLmxlbmd0aC0xXVswXTtyZXR1cm4gdD09PW51bGw/bnVsbDp0aGlzLiN0W3RdfVsoUj12LFApXSgpe3RoaXMuI3QubGVuZ3RoPTEsdGhpcy4jZS5sZW5ndGg9MH1bQ10odCl7bGV0IGU9dGhpcy4jdFt0XTtpZighZSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYmxvY2sgaW5kZXg6ICR7dH1gKTtyZXR1cm4gZX1bSV0odCxlPSExKXtmb3IobGV0W24scl1vZiB0LmJsb2Nrcyl7aWYobiYmZSl7bGV0IHM9bmV3IFVpbnQ4QXJyYXkobmV3IHRoaXMuI28oTnVtYmVyKG4uYnl0ZUxlbmd0aCkpKTtzLnNldChuZXcgVWludDhBcnJheShuKSksbj1zLmJ1ZmZlcn10aGlzLiN0W3JdPW4/bmV3IGEobiwhMSk6bnVsbH10aGlzLiNlPXQuc3RhY2t9W0VdKCl7cmV0dXJue3N0YWNrOnRoaXMuI2Uuc2xpY2UoKSxibG9ja3M6dGhpcy4jdC5tYXAoKHQsZSk9PnQ/dC5sb2NhbD8odC5sb2NhbD0hMSxbdC5idWZmZXIsZV0pOm51bGw6W251bGwsZV0pLmZpbHRlcihCb29sZWFuKX19W3ldKHQpe2lmKCF0KXJldHVybiBudWxsO2lmKHR5cGVvZiB0PT0ic3RyaW5nIiYmKHQ9dGhpcy4jaS5lbmNvZGUodCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZih0LmJ1ZmZlci5jb25zdHJ1Y3Rvcj09PXRoaXMuI28pe2xldCBzPXRoaXMuI3QubGVuZ3RoO3JldHVybiB0aGlzLiN0LnB1c2gobmV3IGEodC5idWZmZXIsITApKSxzfWxldCBlPWEuYWRkcmVzc1RvSW5kZXgodGhpcy5hbGxvYyh0Lmxlbmd0aCkpLG49dGhpcy4jdFtlXTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobi5idWZmZXIpLnNldCh0LDApLGV9cmV0dXJuIHR9W0JdKHQpe3RoaXMuI2UucHVzaChbdCxudWxsLG51bGxdKX1ba10oKXtsZXRbLHQsZV09dGhpcy4jZS5wb3AoKSxuPWU9PT1udWxsPzE6MCxyPWU/P3Qscz1bbnVsbCxudWxsXTtyZXR1cm4gcj09PW51bGx8fHRoaXMuI3Rbcl09PT1udWxsfHwoc1tuXT1yKSxzfX07aW1wb3J0e1dBU0kgYXMgSH1mcm9tIndhc2kiO2ltcG9ydHtkZXZOdWxsIGFzIEx9ZnJvbSJub2RlOm9zIjtpbXBvcnR7b3BlbiBhcyBWfWZyb20ibm9kZTpmcy9wcm9taXNlcyI7aW1wb3J0e2Nsb3NlU3luYyBhcyBPfWZyb20ibm9kZTpmcyI7YXN5bmMgZnVuY3Rpb24gaigpe2xldFtpLHRdPWF3YWl0IFByb21pc2UuYWxsKFtWKEwsInIiKSxWKEwsInciKV0pLGU9ITAsbj1hc3luYygpPT57TyhpKSxPKHQpfTtpZih0eXBlb2YgaSE9Im51bWJlciIpe2xldCByPW5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KHM9Pnt0cnl7ZSYmTyhzKX1jYXRjaHt9fSk7ci5yZWdpc3RlcihpLGkuZmQpLHIucmVnaXN0ZXIodCx0LmZkKSxuPWFzeW5jKCk9PntlPSExLGF3YWl0IFByb21pc2UuYWxsKFtpLmNsb3NlKCksdC5jbG9zZSgpXSkuY2F0Y2goKCk9Pnt9KX19cmV0dXJue2Nsb3NlOm4sZmRzOltpLmZkLHQuZmQsdC5mZF19fWFzeW5jIGZ1bmN0aW9uIE4oaSx0KXtsZXR7Y2xvc2U6ZSxmZHM6W24scixzXX09dD97YXN5bmMgY2xvc2UoKXt9LGZkczpbMCwxLDJdfTphd2FpdCBqKCksbD1uZXcgSCh7dmVyc2lvbjoicHJldmlldzEiLHByZW9wZW5zOmksc3RkaW46bixzdGRvdXQ6cixzdGRlcnI6c30pO3JldHVybnthc3luYyBpbXBvcnRPYmplY3QoKXtyZXR1cm4gbC53YXNpSW1wb3J0fSxhc3luYyBjbG9zZSgpe2F3YWl0IGUoKX0sYXN5bmMgaW5pdGlhbGl6ZShvKXtsZXQgdT1vLmV4cG9ydHMubWVtb3J5O2lmKCF1KXRocm93IG5ldyBFcnJvcigiVGhlIG1vZHVsZSBoYXMgdG8gZXhwb3J0IGEgZGVmYXVsdCBtZW1vcnkuIik7aWYoby5leHBvcnRzLl9pbml0aWFsaXplKXtsZXQgYz1vLmV4cG9ydHMuX2luaXRpYWxpemU7bC5pbml0aWFsaXplP2wuaW5pdGlhbGl6ZSh7ZXhwb3J0czp7bWVtb3J5OnUsX2luaXRpYWxpemU6KCk9PntjKCl9fX0pOmMoKX1lbHNlIGwuc3RhcnQoe2V4cG9ydHM6e21lbW9yeTp1LF9zdGFydDooKT0+e319fSl9fX12YXIgWD0iZXh0aXNtOmhvc3QvZW52IixNPWNsYXNzeyNlOyN0OyNuOyNyPSExOyNpO2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuI2U9dCx0aGlzLiNuPWUsdGhpcy4jdD1uLHRoaXMuI2k9cn1hc3luYyByZXNldCgpe3JldHVybiB0aGlzLmlzQWN0aXZlKCk/ITE6KHRoaXMuI2VbUF0oKSwhMCl9aXNBY3RpdmUoKXtyZXR1cm4gdGhpcy4jcn1hc3luYyBmdW5jdGlvbkV4aXN0cyh0KXt0cnl7bGV0IGU9W10uY29uY2F0KHQpLFtuLHJdPWUubGVuZ3RoPT09Mj9bdGhpcy5sb29rdXBUYXJnZXQoZVswXSksZVsxXV06W3RoaXMuI3QuZmluZChsPT5XZWJBc3NlbWJseS5Nb2R1bGUuZXhwb3J0cyhsLm1vZHVsZSkuZmluZCh1PT51Lm5hbWU9PT1lWzBdJiZ1LmtpbmQ9PT0iZnVuY3Rpb24iKSksZVswXV07cmV0dXJuISghbnx8IW4uaW5zdGFuY2UuZXhwb3J0c1tyXSl9Y2F0Y2h7cmV0dXJuITF9fWFzeW5jIGNhbGxCbG9jayh0LGUpe3RoaXMuI3I9ITA7bGV0IG49W10uY29uY2F0KHQpLFtyLHNdPW4ubGVuZ3RoPT09Mj9bdGhpcy5sb29rdXBUYXJnZXQoblswXSksblsxXV06W3RoaXMuI3QuZmluZChvPT5XZWJBc3NlbWJseS5Nb2R1bGUuZXhwb3J0cyhvLm1vZHVsZSkuZmluZChjPT5jLm5hbWU9PT1uWzBdJiZjLmtpbmQ9PT0iZnVuY3Rpb24iKSksblswXV07aWYoIXIpdGhyb3cgRXJyb3IoYFBsdWdpbiBlcnJvcjogdGFyZ2V0ICIke24uam9pbignIiAiJyl9IiBkb2VzIG5vdCBleGlzdGApO2xldCBsPXIuaW5zdGFuY2UuZXhwb3J0c1tzXTtpZighbCl0aHJvdyBFcnJvcihgUGx1Z2luIGVycm9yOiBmdW5jdGlvbiAiJHtuLmpvaW4oJyIgIicpfSIgZG9lcyBub3QgZXhpc3RgKTt0aGlzLiNlW0JdKGU/P251bGwpO3RyeXtyZXR1cm4gbCgpLHRoaXMuI2Vba10oKX1jYXRjaChvKXt0aHJvdyB0aGlzLiNlW2tdKCksb31maW5hbGx5e3RoaXMuI3I9ITF9fWFzeW5jIGNhbGwodCxlKXtsZXQgbj10aGlzLiNlW3ldKGUpLFtyLHNdPWF3YWl0IHRoaXMuY2FsbEJsb2NrKHQsbiksbD1yIT09bnVsbCxvPXI/P3M7aWYobz09PW51bGwpcmV0dXJuIG51bGw7bGV0IHU9dGhpcy4jZVtDXShvKTtpZighdSlyZXR1cm4gbnVsbDtsZXQgYz1uZXcgYih1LmJ1ZmZlcik7aWYobCl0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbi1vcmlnaW5hdGVkIGVycm9yOiAke2Muc3RyaW5nKCl9YCk7cmV0dXJuIGN9bG9va3VwVGFyZ2V0KHQpe2xldCBlPVN0cmluZyh0Pz8iMCIpLG49dGhpcy4jbi5maW5kSW5kZXgocj0+cj09PWUpO2lmKG49PT0tMSl0aHJvdyBuZXcgRXJyb3IoYG5vIG1vZHVsZSBuYW1lZCAiJHt0fSJgKTtyZXR1cm4gdGhpcy4jdFtuXX1hc3luYyBnZXRFeHBvcnRzKHQpe3JldHVybiBXZWJBc3NlbWJseS5Nb2R1bGUuZXhwb3J0cyh0aGlzLmxvb2t1cFRhcmdldCh0KS5tb2R1bGUpfHxbXX1hc3luYyBnZXRJbXBvcnRzKHQpe3JldHVybiBXZWJBc3NlbWJseS5Nb2R1bGUuaW1wb3J0cyh0aGlzLmxvb2t1cFRhcmdldCh0KS5tb2R1bGUpfHxbXX1hc3luYyBnZXRJbnN0YW5jZSh0KXtyZXR1cm4gdGhpcy5sb29rdXBUYXJnZXQodCkuaW5zdGFuY2V9YXN5bmMgY2xvc2UoKXt0aGlzLiNpJiYoYXdhaXQgdGhpcy4jaS5jbG9zZSgpLHRoaXMuI2k9bnVsbCl9fTthc3luYyBmdW5jdGlvbiAkKGksdCxlLG49bmV3IGQoQXJyYXlCdWZmZXIsaS5sb2dnZXIsaS5jb25maWcpKXtsZXQgcj1pLndhc2lFbmFibGVkP2F3YWl0IE4oaS5hbGxvd2VkUGF0aHMsaS5lbmFibGVXYXNpT3V0cHV0KTpudWxsLHM9ey4uLnI/e3dhc2lfc25hcHNob3RfcHJldmlldzE6YXdhaXQgci5pbXBvcnRPYmplY3QoKX06e30sW1hdOm5bdl0sZW52Ont9fTtmb3IobGV0IG8gaW4gaS5mdW5jdGlvbnMpe3Nbb109c1tvXXx8e307Zm9yKGxldCB1IGluIGkuZnVuY3Rpb25zW29dKXNbb11bdV09aS5mdW5jdGlvbnNbb11bdV0uYmluZChudWxsLG4pfWxldCBsPWF3YWl0IFByb21pc2UuYWxsKGUubWFwKGFzeW5jIG89PntsZXQgdT1hd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShvLHMpO3ImJmF3YWl0IHI/LmluaXRpYWxpemUodSk7bGV0IGM9dS5leHBvcnRzLmhzX2luaXQ/Imhhc2tlbGwiOnUuZXhwb3J0cy5faW5pdGlhbGl6ZT8icmVhY3RvciI6dS5leHBvcnRzLl9zdGFydD8iY29tbWFuZCI6Im5vbmUiO3JldHVybih1LmV4cG9ydHMuaHNfaW5pdD91LmV4cG9ydHMuaHNfaW5pdDooKT0+e30pKCkse21vZHVsZTpvLGluc3RhbmNlOnUsZ3Vlc3RUeXBlOmN9fSkpO3JldHVybiBuZXcgTShuLHQsbCxyKX12YXIgXz01ZTMsVz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoIlRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlOiB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBiZSBpbnZva2VkIGFzIGEgd2ViIHdvcmtlci4iKTt0aGlzLnNoYXJlZERhdGE9bnVsbCx0aGlzLnNoYXJlZERhdGFWaWV3PW51bGwsdGhpcy5ob3N0RmxhZz1udWxsLHRoaXMucG9ydD10LHRoaXMucG9ydC5vbigibWVzc2FnZSIsZT0+dGhpcy5oYW5kbGVNZXNzYWdlKGUpKSx0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe3R5cGU6ImluaXRpYWxpemVkIn0pLHRoaXMuZHluYW1pY0hhbmRsZXJzPW5ldyBNYXAsdGhpcy5keW5hbWljSGFuZGxlcnMuc2V0KCJjYWxsIixhc3luYyhlLG4scixzKT0+e2lmKCF0aGlzLmNvbnRleHQpdGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIHN0YXRlOiBubyBjb250ZXh0IGF2YWlsYWJsZSB0byB3b3JrZXIgcmVhY3RvciIpO3RoaXMuY29udGV4dFtJXShzKTtsZXQgbD1hd2FpdCB0aGlzLnBsdWdpbj8uY2FsbEJsb2NrKG4scikudGhlbihvPT5bbnVsbCxvXSxvPT5bbyxudWxsXSk7cz10aGlzLmNvbnRleHRbRV0oKTtmb3IobGV0W29db2Ygcy5ibG9ja3MpbyYmZS5wdXNoKG8pO3JldHVybiBsWzBdJiYobFswXT17b3JpZ2luYWxTdGFjazpsWzBdPy5zdGFjayxtZXNzYWdlOmxbMF0/Lm1lc3NhZ2V9KSx7cmVzdWx0czpsLHN0YXRlOnN9fSksdGhpcy5keW5hbWljSGFuZGxlcnMuc2V0KCJyZXNldCIsYXN5bmMgZT0+dGhpcy5wbHVnaW4/LnJlc2V0KCkpLHRoaXMuZHluYW1pY0hhbmRsZXJzLnNldCgiZ2V0RXhwb3J0cyIsYXN5bmMoZSxuKT0+dGhpcy5wbHVnaW4/LmdldEV4cG9ydHMobikpLHRoaXMuZHluYW1pY0hhbmRsZXJzLnNldCgiZ2V0SW1wb3J0cyIsYXN5bmMoZSxuKT0+dGhpcy5wbHVnaW4/LmdldEltcG9ydHMobikpLHRoaXMuZHluYW1pY0hhbmRsZXJzLnNldCgiZnVuY3Rpb25FeGlzdHMiLGFzeW5jKGUsbik9PnRoaXMucGx1Z2luPy5mdW5jdGlvbkV4aXN0cyhuKSl9YXN5bmMgaGFuZGxlTWVzc2FnZSh0KXtzd2l0Y2godC50eXBlKXtjYXNlImluaXQiOnJldHVybiBhd2FpdCB0aGlzLmhhbmRsZUluaXQodCk7Y2FzZSJpbnZva2UiOnJldHVybiBhd2FpdCB0aGlzLmhhbmRsZUludm9rZSh0KX19YXN5bmMgaGFuZGxlSW52b2tlKHQpe2xldCBlPXRoaXMuZHluYW1pY0hhbmRsZXJzLmdldCh0LmhhbmRsZXIpO2lmKCFlKXJldHVybiB0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe3R5cGU6InJldHVybiIscmVzdWx0Oltgbm8gaGFuZGxlciByZWdpc3RlcmVkIGZvciAke3QuaGFuZGxlcn1gLG51bGxdfSk7bGV0IG49W10scj1hd2FpdCBlKG4sLi4udC5hcmdzfHxbXSkudGhlbihzPT5bbnVsbCxzXSxzPT5bcyxudWxsXSk7cmV0dXJuIHJbMF0mJihyWzBdPXtvcmlnaW5hbFN0YWNrOnJbMF0/LnN0YWNrLG1lc3NhZ2U6clswXT8ubWVzc2FnZX0pLHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToicmV0dXJuIixyZXN1bHRzOnJ9LG4pfWFzeW5jIGhhbmRsZUluaXQodCl7dGhpcy5zaGFyZWREYXRhPXQuc2hhcmVkRGF0YSx0aGlzLnNoYXJlZERhdGFWaWV3PW5ldyBEYXRhVmlldyh0LnNoYXJlZERhdGEpLHRoaXMuaG9zdEZsYWc9bmV3IEludDMyQXJyYXkodGhpcy5zaGFyZWREYXRhKTtsZXQgZT1PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModC5mdW5jdGlvbnMpLm1hcCgoW2MsaF0pPT5bYyxPYmplY3QuZnJvbUVudHJpZXMoaC5tYXAobT0+W20sKHcsLi4ueik9PnRoaXMuY2FsbEhvc3QodyxjLG0seildKSldKSkse3R5cGU6bixtb2R1bGVzOnIsZnVuY3Rpb25zOnMsLi4ubH09dCxvPWM9Pmg9PnRoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToibG9nIixsZXZlbDpjLG1lc3NhZ2U6aH0pLHU9T2JqZWN0LmZyb21FbnRyaWVzKFsiaW5mbyIsImRlYnVnIiwid2FybiIsImVycm9yIl0ubWFwKGM9PltjLG8oYyldKSk7dGhpcy5jb250ZXh0PW5ldyBkKEFycmF5QnVmZmVyLHUsdC5jb25maWcpLHRoaXMucGx1Z2luPWF3YWl0ICQoey4uLmwsZnVuY3Rpb25zOmUsZmV0Y2gsbG9nZ2VyOnV9LHQubmFtZXMscix0aGlzLmNvbnRleHQpLHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7dHlwZToicmVhZHkifSl9Y2FsbEhvc3QodCxlLG4scil7aWYoIXRoaXMuaG9zdEZsYWcpdGhyb3cgbmV3IEVycm9yKCJhdHRlbXB0ZWQgdG8gY2FsbCBob3N0IGJlZm9yZSByZWNlaXZpbmcgc2hhcmVkIGFycmF5IGJ1ZmZlciIpO2xldCBzPXRbRV0oKTt0aGlzLnBvcnQucG9zdE1lc3NhZ2Uoe3R5cGU6Imludm9rZSIsbmFtZXNwYWNlOmUsZnVuYzpuLGFyZ3M6cixzdGF0ZTpzfSk7bGV0IGw9bmV3IGcodGhpcy5zaGFyZWREYXRhKSxvPVtdLHU7ZG97bGV0IGM9bC5yZWFkVWludDgoKTtzd2l0Y2goYyl7Y2FzZSAwOnJldHVybiBzLmJsb2Nrcz1vLHRbSV0ocyksbC5jbG9zZSgpLHRoaXMuaG9zdEZsYWdbMF09Zy5TQUJfQkFTRV9PRkZTRVQsdTtjYXNlIDE6dT1sLnJlYWRVaW50NjQoKTticmVhaztjYXNlIDI6dT1sLnJlYWRGbG9hdDY0KCk7YnJlYWs7Y2FzZSAzOnU9dm9pZCAwO2JyZWFrO2Nhc2UgNDp7bGV0IGg9bC5yZWFkVWludDMyKCksbT1sLnJlYWRVaW50MzIoKTtpZighbSlvLnB1c2goW251bGwsaF0pO2Vsc2V7bGV0IHc9bmV3IFVpbnQ4QXJyYXkobSk7bC5yZWFkKHcpLG8ucHVzaChbdy5idWZmZXIsaF0pfX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWN0aW9uIHR5cGU9IiR7Y30iOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSAoaHR0cHM6Ly9naXRodWIuY29tL2V4dGlzbS9qcy1zZGsvaXNzdWVzL25ldz90aXRsZT1zaGFyZWQrYXJyYXkrYnVmZmVyK2JhZCtzZWN0aW9uK3R5cGUrJHtjfSZsYWJlbHM9YnVnKWApfX13aGlsZSgxKX19O25ldyBXKEcpO3ZhciBmPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuaW5wdXQ9dCx0aGlzLmlucHV0T2Zmc2V0PWYuU0FCX0JBU0VfT0ZGU0VULHRoaXMuZmxhZz1uZXcgSW50MzJBcnJheSh0aGlzLmlucHV0KSx0aGlzLnNjcmF0Y2g9bmV3IEFycmF5QnVmZmVyKDgpLHRoaXMuc2NyYXRjaFZpZXc9bmV3IERhdGFWaWV3KHRoaXMuc2NyYXRjaCksdGhpcy5leHBlY3RlZD0wLHRoaXMucHVsbCghMSl9Z2V0IGF2YWlsYWJsZSgpe3JldHVybiB0aGlzLmZsYWdbMF0tdGhpcy5pbnB1dE9mZnNldH1jbG9zZSgpe2Zvcig7QXRvbWljcy5jb21wYXJlRXhjaGFuZ2UodGhpcy5mbGFnLGYuU0FCX0lEWCx0aGlzLmV4cGVjdGVkLGYuU0FCX0JBU0VfT0ZGU0VUKSE9PWYuU0FCX0JBU0VfT0ZGU0VUOyk7QXRvbWljcy5ub3RpZnkodGhpcy5mbGFnLGYuU0FCX0lEWCxfKX1wdWxsKHQ9ITApe2lmKHQpe2Zvcig7QXRvbWljcy5jb21wYXJlRXhjaGFuZ2UodGhpcy5mbGFnLGYuU0FCX0lEWCx0aGlzLmV4cGVjdGVkLGYuU0FCX0JBU0VfT0ZGU0VUKSE9PWYuU0FCX0JBU0VfT0ZGU0VUOyk7QXRvbWljcy5ub3RpZnkodGhpcy5mbGFnLGYuU0FCX0lEWCxfKX1sZXQgZT1BdG9taWNzLndhaXQodGhpcy5mbGFnLDAsZi5TQUJfQkFTRV9PRkZTRVQsXyk7aWYodGhpcy5leHBlY3RlZD1BdG9taWNzLmxvYWQodGhpcy5mbGFnLDApLGU9PT0idGltZWQtb3V0Iil0aHJvdyBuZXcgRXJyb3IoYFdvcmtlciB0aW1lZCBvdXQgd2FpdGluZyBmb3IgcmVzcG9uc2UgZnJvbSBob3N0IGFmdGVyICR7X31tcyAke3RoaXMuZmxhZ1swXX1gKTt0aGlzLmlucHV0T2Zmc2V0PWYuU0FCX0JBU0VfT0ZGU0VUfXJlYWQodCl7aWYodC5ieXRlTGVuZ3RoPHRoaXMuYXZhaWxhYmxlKXt0LnNldChuZXcgVWludDhBcnJheSh0aGlzLmlucHV0KS5zdWJhcnJheSh0aGlzLmlucHV0T2Zmc2V0LHRoaXMuaW5wdXRPZmZzZXQrdC5ieXRlTGVuZ3RoKSksdGhpcy5pbnB1dE9mZnNldCs9dC5ieXRlTGVuZ3RoO3JldHVybn1sZXQgZT0wLG49dGhpcy5hdmFpbGFibGU7ZG97aWYodC5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5pbnB1dCkuc3ViYXJyYXkodGhpcy5pbnB1dE9mZnNldCx0aGlzLmlucHV0T2Zmc2V0K24pLGUpLGUrPW4sdGhpcy5pbnB1dE9mZnNldCs9bixlPT09dC5ieXRlTGVuZ3RofHx0aGlzLmF2YWlsYWJsZTwwKWJyZWFrO3RoaXMucHVsbCgpLG49TWF0aC5taW4oTWF0aC5tYXgodGhpcy5hdmFpbGFibGUsMCksdC5ieXRlTGVuZ3RoLWUpfXdoaWxlKGUhPT10LmJ5dGVMZW5ndGgpfXJlYWRVaW50OCgpe3JldHVybiB0aGlzLnJlYWQobmV3IFVpbnQ4QXJyYXkodGhpcy5zY3JhdGNoKS5zdWJhcnJheSgwLDEpKSx0aGlzLnNjcmF0Y2hWaWV3LmdldFVpbnQ4KDApfXJlYWRVaW50MzIoKXtyZXR1cm4gdGhpcy5yZWFkKG5ldyBVaW50OEFycmF5KHRoaXMuc2NyYXRjaCkuc3ViYXJyYXkoMCw0KSksdGhpcy5zY3JhdGNoVmlldy5nZXRVaW50MzIoMCwhMCl9cmVhZFVpbnQ2NCgpe3JldHVybiB0aGlzLnJlYWQobmV3IFVpbnQ4QXJyYXkodGhpcy5zY3JhdGNoKSksdGhpcy5zY3JhdGNoVmlldy5nZXRCaWdVaW50NjQoMCwhMCl9cmVhZEZsb2F0NjQoKXtyZXR1cm4gdGhpcy5yZWFkKG5ldyBVaW50OEFycmF5KHRoaXMuc2NyYXRjaCkpLHRoaXMuc2NyYXRjaFZpZXcuZ2V0RmxvYXQ2NCgwLCEwKX19LGc9ZjtnLlNBQl9JRFg9MCxnLlNBQl9CQVNFX09GRlNFVD00OwovLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXIuanMubWFwCg==\");\n", "import { CallContext, RESET, IMPORT_STATE, EXPORT_STATE, STORE, GET_BLOCK } from './call-context.ts';\nimport { PluginOutput, type InternalConfig } from './interfaces.ts';\nimport { WORKER_URL } from './worker-url.ts';\nimport { Worker } from 'node:worker_threads';\nimport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\nimport { EXTISM_ENV } from './foreground-plugin.ts';\nimport { matches } from './polyfills/deno-minimatch.ts';\n\nconst MAX_WAIT = 5000;\n\nenum SharedArrayBufferSection {\n  End = 0,\n  RetI64 = 1,\n  RetF64 = 2,\n  RetVoid = 3,\n  Block = 4,\n}\n\n// Firefox has not yet implemented Atomics.waitAsync, but we can polyfill\n// it using a worker as a one-off.\n//\n// TODO: we should probably give _each_ background plugin its own waiter\n// script.\nconst AtomicsWaitAsync =\n  Atomics.waitAsync ||\n  (() => {\n    const src = `onmessage = ev => {\n    const [b, i, v] = ev.data\n    const f = new Int32Array(b)\n    postMessage(Atomics.wait(f, i, v));\n  }`;\n\n    const blob = new (Blob as any)([src], { type: 'text/javascript' });\n    const url = URL.createObjectURL(blob);\n    const w = new Worker(url);\n    return (ia: any, index, value) => {\n      const promise = new Promise((resolve) => {\n        w.once('message', (data) => {\n          resolve(data);\n        });\n      });\n      w.postMessage([ia.buffer, index, value]);\n      return { async: true, value: promise };\n    };\n  })();\n\nclass BackgroundPlugin {\n  worker: Worker;\n  sharedData: SharedArrayBuffer;\n  sharedDataView: DataView;\n  hostFlag: Int32Array;\n  opts: InternalConfig;\n\n  #context: CallContext;\n  #request: [(result: any[]) => void, (result: any[]) => void] | null = null;\n\n  constructor(worker: Worker, sharedData: SharedArrayBuffer, opts: InternalConfig, context: CallContext) {\n    this.worker = worker;\n    this.sharedData = sharedData;\n    this.sharedDataView = new DataView(sharedData);\n    this.hostFlag = new Int32Array(sharedData);\n    this.opts = opts;\n    this.#context = context;\n\n    this.hostFlag[0] = RingBufferWriter.SAB_BASE_OFFSET;\n\n    this.worker.on('message', (ev) => this.#handleMessage(ev));\n  }\n\n  async reset(): Promise<boolean> {\n    if (this.isActive()) {\n      return false;\n    }\n\n    await this.#invoke('reset');\n\n    this.#context[RESET]();\n    return true;\n  }\n\n  isActive() {\n    return Boolean(this.#request);\n  }\n\n  async #handleMessage(ev: any) {\n    switch (ev?.type) {\n      case 'invoke':\n        return this.#handleInvoke(ev);\n      case 'return':\n        return this.#handleReturn(ev);\n      case 'log':\n        return this.#handleLog(ev);\n    }\n  }\n\n  #handleLog(ev: any) {\n    const fn = (this.opts.logger as any)[ev.level as string];\n    if (typeof fn !== 'function') {\n      this.opts.logger?.error(`failed to find loglevel=\"${ev.level}\" on logger: message=${ev.message}`);\n    } else {\n      fn.call(this.opts.logger, ev.message);\n    }\n  }\n\n  #handleReturn(ev: any) {\n    const responder = this.#request || null;\n    if (responder === null) {\n      // This is fatal, we should probably panic\n      throw new Error(`received \"return\" call with no corresponding request`);\n    }\n\n    this.#request = null;\n\n    const [resolve, reject] = responder;\n\n    if (!Array.isArray(ev.results) || ev.results.length !== 2) {\n      return reject(new Error(`received malformed \"return\"`) as any);\n    }\n\n    const [err, data] = ev.results;\n\n    err ? reject(err) : resolve(data);\n  }\n\n  // host -> guest() invoke\n  async #invoke(handler: string, ...args: any[]): Promise<any> {\n    if (this.#request) {\n      throw new Error('plugin is not reentrant');\n    }\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    this.#request = [resolve as any, reject as any];\n\n    this.worker.postMessage({\n      type: 'invoke',\n      handler,\n      args,\n    });\n\n    return promise;\n  }\n\n  async functionExists(funcName: string | [string, string]): Promise<boolean> {\n    return await this.#invoke('functionExists', funcName);\n  }\n\n  // host -> guest invoke()\n  async call(funcName: string | [string, string], input?: string | Uint8Array): Promise<PluginOutput | null> {\n    const index = this.#context[STORE](input);\n\n    const [errorIdx, outputIdx] = await this.callBlock(funcName, index);\n\n    const shouldThrow = errorIdx !== null;\n    const idx = errorIdx ?? outputIdx;\n\n    if (idx === null) {\n      return null;\n    }\n\n    const block = this.#context[GET_BLOCK](idx);\n\n    if (block === null) {\n      return null;\n    }\n\n    const buf = new PluginOutput(\n      CAPABILITIES.allowSharedBufferCodec ? block.buffer : new Uint8Array(block.buffer).slice().buffer,\n    );\n\n    if (shouldThrow) {\n      const msg = new TextDecoder().decode(buf);\n      throw new Error(`Plugin-originated error: ${msg}`);\n    }\n\n    return buf;\n  }\n\n  async callBlock(funcName: string | [string, string], input: number | null): Promise<[number | null, number | null]> {\n    const exported = this.#context[EXPORT_STATE]();\n    const { results, state } = await this.#invoke('call', funcName, input, exported);\n    this.#context[IMPORT_STATE](state, true);\n\n    const [err, data] = results;\n    if (err) {\n      throw err;\n    }\n\n    return data;\n  }\n\n  // guest -> host invoke()\n  async #handleInvoke(ev: any) {\n    const writer = new RingBufferWriter(this.sharedData);\n    const namespace = this.opts.functions[ev.namespace];\n    const func = (namespace ?? {})[ev.func];\n    try {\n      if (!func) {\n        throw Error(`Plugin error: host function \"${ev.namespace}\" \"${ev.func}\" does not exist`);\n      }\n\n      this.#context[IMPORT_STATE](ev.state, true);\n\n      const data = await func(this.#context, ...ev.args);\n\n      const { blocks } = this.#context[EXPORT_STATE]();\n\n      // Writes to the ring buffer MAY return a promise if the write would wrap.\n      // Writes that fit within the ring buffer return void.\n      let promise: any;\n      for (const [buffer, destination] of blocks) {\n        promise = writer.writeUint8(SharedArrayBufferSection.Block);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint32(destination);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint32(buffer?.byteLength || 0);\n        if (promise) {\n          await promise;\n        }\n\n        if (buffer) {\n          promise = writer.write(buffer);\n          if (promise) {\n            await promise;\n          }\n        }\n      }\n\n      if (typeof data === 'bigint') {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetI64);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeUint64(data);\n        if (promise) {\n          await promise;\n        }\n      } else if (typeof data === 'number') {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetF64);\n        if (promise) {\n          await promise;\n        }\n\n        promise = writer.writeFloat64(data);\n        if (promise) {\n          await promise;\n        }\n      } else {\n        promise = writer.writeUint8(SharedArrayBufferSection.RetVoid);\n        if (promise) {\n          await promise;\n        }\n      }\n\n      promise = writer.writeUint8(SharedArrayBufferSection.End);\n      if (promise) {\n        await promise;\n      }\n      await writer.flush();\n    } catch (err) {\n      this.close();\n      const [, reject] = this.#request as any[];\n      this.#request = null;\n      return reject(err);\n    }\n  }\n\n  async getExports(name?: string): Promise<WebAssembly.ModuleExportDescriptor[]> {\n    return await this.#invoke('getExports', name ?? '0');\n  }\n\n  async getImports(name?: string): Promise<WebAssembly.ModuleImportDescriptor[]> {\n    return await this.#invoke('getImports', name ?? '0');\n  }\n\n  async getInstance(): Promise<WebAssembly.Instance> {\n    throw new Error('todo');\n  }\n\n  async close(): Promise<void> {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null as any;\n    }\n  }\n}\n\nclass HttpContext {\n  fetch: typeof fetch;\n  lastStatusCode: number;\n  allowedHosts: string[];\n\n  constructor(_fetch: typeof fetch, allowedHosts: string[]) {\n    this.fetch = _fetch;\n    this.allowedHosts = allowedHosts;\n    this.lastStatusCode = 0;\n  }\n\n  contribute(functions: Record<string, Record<string, any>>) {\n    functions[EXTISM_ENV] ??= {};\n    functions[EXTISM_ENV].http_request = (callContext: CallContext, reqaddr: bigint, bodyaddr: bigint) =>\n      this.makeRequest(callContext, reqaddr, bodyaddr);\n    functions[EXTISM_ENV].http_status_code = () => this.lastStatusCode;\n  }\n\n  async makeRequest(callContext: CallContext, reqaddr: bigint, bodyaddr: bigint) {\n    const req = callContext.read(reqaddr);\n    if (req === null) {\n      return 0n;\n    }\n\n    const { header, url: rawUrl, method: m } = req.json();\n    const method = m ?? 'GET';\n    const url = new URL(rawUrl);\n\n    const isAllowed = this.allowedHosts.some((allowedHost) => {\n      return allowedHost === url.hostname || matches(url.hostname, allowedHost);\n    });\n\n    if (!isAllowed) {\n      throw new Error(`Call error: HTTP request to \"${url}\" is not allowed (no allowedHosts match \"${url.hostname}\")`);\n    }\n\n    const body = bodyaddr === 0n || method === 'GET' || method === 'HEAD' ? null : callContext.read(bodyaddr)?.bytes();\n    const fetch = this.fetch;\n    const response = await fetch(rawUrl, {\n      headers: header,\n      method,\n      ...(body ? { body: body.slice() } : {}),\n    });\n\n    this.lastStatusCode = response.status;\n    const result = callContext.store(new Uint8Array(await response.arrayBuffer()));\n\n    return result;\n  }\n}\n\nexport async function createBackgroundPlugin(\n  opts: InternalConfig,\n  names: string[],\n  modules: WebAssembly.Module[],\n): Promise<BackgroundPlugin> {\n  const worker = new Worker(WORKER_URL);\n  const context = new CallContext(SharedArrayBuffer, opts.logger, opts.config);\n  const httpContext = new HttpContext(opts.fetch, opts.allowedHosts);\n  httpContext.contribute(opts.functions);\n\n  await new Promise((resolve, reject) => {\n    worker.on('message', function handler(ev) {\n      if (ev?.type !== 'initialized') {\n        reject(new Error(`received unexpected message (type=${ev?.type})`));\n      }\n\n      worker.removeListener('message', handler);\n      resolve(null);\n    });\n  });\n\n  // NB(chrisdickinson): We *have* to create the SharedArrayBuffer in\n  // the parent context because -- for whatever reason! -- chromium does\n  // not allow the creation of shared buffers in worker contexts, but firefox\n  // and webkit do.\n  const sharedData = new (SharedArrayBuffer as any)(opts.sharedArrayBufferSize);\n\n  const { fetch: _, logger: __, ...rest } = opts;\n  const message = {\n    ...rest,\n    type: 'init',\n    functions: Object.fromEntries(Object.entries(opts.functions || {}).map(([k, v]) => [k, Object.keys(v)])),\n    names,\n    modules,\n    sharedData,\n  };\n\n  const onready = new Promise((resolve, reject) => {\n    worker.on('message', function handler(ev) {\n      if (ev?.type !== 'ready') {\n        reject(new Error(`received unexpected message (type=${ev?.type})`));\n      }\n\n      worker.removeListener('message', handler);\n      resolve(null);\n    });\n  });\n\n  worker.postMessage(message);\n  await onready;\n\n  return new BackgroundPlugin(worker, sharedData, opts, context);\n}\n\nclass RingBufferWriter {\n  output: SharedArrayBuffer;\n  scratch: ArrayBuffer;\n  scratchView: DataView;\n  outputOffset: number;\n  flag: Int32Array;\n\n  static SAB_IDX = 0;\n  static SAB_BASE_OFFSET = 4;\n\n  constructor(output: SharedArrayBuffer) {\n    this.scratch = new ArrayBuffer(8);\n    this.scratchView = new DataView(this.scratch);\n    this.output = output;\n    this.outputOffset = RingBufferWriter.SAB_BASE_OFFSET;\n    this.flag = new Int32Array(this.output);\n  }\n\n  async flush() {\n    if (this.outputOffset === RingBufferWriter.SAB_BASE_OFFSET) {\n      // no need to flush -- we haven't written anything!\n      return;\n    }\n\n    const targetOffset = this.outputOffset;\n    this.outputOffset = RingBufferWriter.SAB_BASE_OFFSET;\n\n    while (\n      Atomics.compareExchange(this.flag, RingBufferWriter.SAB_IDX, RingBufferWriter.SAB_BASE_OFFSET, targetOffset) !==\n      targetOffset\n    ) {} // eslint-disable-line no-empty\n    Atomics.notify(this.flag, RingBufferWriter.SAB_IDX, 1);\n\n    // wait for the thread to read the data out...\n    const result = AtomicsWaitAsync(this.flag, RingBufferWriter.SAB_IDX, targetOffset, MAX_WAIT);\n\n    // XXX(chrisdickinson): this is c\u00FCrs\u00EBd code. Add a setTimeout because some platforms\n    // don't spin their event loops if the only pending item is a Promise generated by Atomics.waitAsync.\n    //\n    // - https://github.com/nodejs/node/pull/44409\n    // - https://github.com/denoland/deno/issues/14786\n    let timer;\n    try {\n      timer = setInterval(() => {}, 0);\n      if (result.async) {\n        result.value = (await result.value) as any;\n      }\n    } finally {\n      clearInterval(timer);\n    }\n\n    if (result.value === 'timed-out') {\n      throw new Error(`encountered timeout while flushing host function to worker memory ${this.flag[0]}`);\n    }\n  }\n\n  async spanningWrite(input: Uint8Array) {\n    let inputOffset = 0;\n    let toWrite = this.output.byteLength - this.outputOffset;\n    let flushedWriteCount =\n      1 + Math.floor((input.byteLength - toWrite) / (this.output.byteLength - RingBufferWriter.SAB_BASE_OFFSET));\n    const finalWrite = (input.byteLength - toWrite) % (this.output.byteLength - RingBufferWriter.SAB_BASE_OFFSET);\n    do {\n      new Uint8Array(this.output).set(input.subarray(inputOffset, inputOffset + toWrite), this.outputOffset);\n      this.outputOffset += toWrite;\n      inputOffset += toWrite;\n      await this.flush();\n      toWrite = this.output.byteLength - RingBufferWriter.SAB_BASE_OFFSET;\n      --flushedWriteCount;\n    } while (flushedWriteCount != 0);\n\n    if (finalWrite) {\n      this.write(input.subarray(inputOffset, inputOffset + finalWrite));\n    }\n  }\n\n  write(bytes: ArrayBufferLike): void | Promise<void> {\n    if (bytes.byteLength + this.outputOffset < this.output.byteLength) {\n      new Uint8Array(this.output).set(new Uint8Array(bytes), this.outputOffset);\n      this.outputOffset += bytes.byteLength;\n      return;\n    }\n\n    return this.spanningWrite(new Uint8Array(bytes));\n  }\n\n  writeUint8(value: number): void | Promise<void> {\n    this.scratchView.setUint8(0, value);\n    return this.write(this.scratch.slice(0, 1));\n  }\n\n  writeUint32(value: number): void | Promise<void> {\n    this.scratchView.setUint32(0, value, true);\n    return this.write(this.scratch.slice(0, 4));\n  }\n\n  writeUint64(value: bigint): void | Promise<void> {\n    this.scratchView.setBigUint64(0, value, true);\n    return this.write(this.scratch.slice(0, 8));\n  }\n\n  writeFloat64(value: number): void | Promise<void> {\n    this.scratchView.setFloat64(0, value, true);\n    return this.write(this.scratch.slice(0, 8));\n  }\n}\n", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import { minimatch } from 'minimatch';\n\nexport function matches(text: string, pattern: string): boolean {\n  return minimatch(text, pattern);\n}\n", "import { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nimport type { ManifestLike, InternalConfig, ExtismPluginOptions, Plugin } from './interfaces.ts';\n\nimport { toWasmModuleData as _toWasmModuleData } from './manifest.ts';\n\nimport { createForegroundPlugin as _createForegroundPlugin } from './foreground-plugin.ts';\nimport { createBackgroundPlugin as _createBackgroundPlugin } from './background-plugin.ts';\n\nexport { CAPABILITIES } from './polyfills/deno-capabilities.ts';\n\nexport type {\n  Capabilities,\n  ExtismPluginOptions,\n  ManifestLike,\n  ManifestWasmResponse,\n  ManifestWasmModule,\n  ManifestWasmData,\n  ManifestWasmUrl,\n  ManifestWasmPath,\n  ManifestWasm,\n  Manifest,\n  Plugin,\n  PluginOutput,\n} from './interfaces.ts';\n\nexport type { CallContext, CallContext as CurrentPlugin } from './call-context.ts';\n\n/**\n * Create a {@link Plugin} given a {@link ManifestLike} and {@link ExtismPluginOptions}.\n *\n * Plugins wrap Wasm modules, exposing rich access to exported functions.\n *\n * ```ts\n * const plugin = await createPlugin(\n *   'https://github.com/extism/plugins/releases/download/v0.3.0/count_vowels.wasm',\n *   { useWasi: true }\n * );\n *\n * try {\n *   const result = await plugin.call('count_vowels', 'hello world');\n *   const parsed = result.json();\n *\n *   console.log(parsed); // { count: 3, total: 3, vowels: \"aeiouAEIOU\" }\n * } finally {\n *   await plugin.close();\n * }\n * ```\n *\n * {@link Plugin | `Plugin`} can run on a background thread when the\n * environment supports it. You can see if the current environment supports\n * background plugins by checking the {@link Capabilities#hasWorkerCapability |\n * `hasWorkerCapability`} property of {@link CAPABILITIES}.\n *\n * @param manifest A {@link ManifestLike | `ManifestLike`}. May be a `string`\n * representing a URL, JSON, a path to a wasm file ({@link\n * Capabilities#manifestSupportsPaths | in environments} where paths are\n * supported); an [ArrayBuffer](https://mdn.io/ArrayBuffer); or a {@link\n * Manifest}.\n *\n * @param opts {@link ExtismPluginOptions | options} for controlling the behavior\n * of the plugin.\n *\n * @returns a promise for a {@link Plugin}.\n */\nexport async function createPlugin(\n  manifest: ManifestLike | PromiseLike<ManifestLike>,\n  opts: ExtismPluginOptions = {},\n): Promise<Plugin> {\n  opts = { ...opts };\n  opts.useWasi ??= false;\n  opts.enableWasiOutput ??= opts.useWasi ? CAPABILITIES.extismStdoutEnvVarSet : false;\n  opts.functions = opts.functions || {};\n  opts.allowedPaths ??= {};\n  opts.allowedHosts ??= <any>[].concat(opts.allowedHosts || []);\n  opts.logger ??= console;\n  opts.config ??= {};\n  opts.fetch ??= fetch;\n\n  // TODO(chrisdickinson): reset this to `CAPABILITIES.hasWorkerCapability` once we've fixed https://github.com/extism/js-sdk/issues/46.\n  opts.runInWorker ??= false;\n  if (opts.runInWorker && !CAPABILITIES.hasWorkerCapability) {\n    throw new Error(\n      'Cannot enable off-thread wasm; current context is not `crossOriginIsolated` (see https://mdn.io/crossOriginIsolated)',\n    );\n  }\n\n  const [names, moduleData] = await _toWasmModuleData(await Promise.resolve(manifest), opts.fetch ?? fetch);\n\n  const ic: InternalConfig = {\n    allowedHosts: opts.allowedHosts as [],\n    allowedPaths: opts.allowedPaths,\n    functions: opts.functions,\n    fetch: opts.fetch || fetch,\n    wasiEnabled: opts.useWasi,\n    logger: opts.logger,\n    config: opts.config,\n    enableWasiOutput: opts.enableWasiOutput,\n    sharedArrayBufferSize: Number(opts.sharedArrayBufferSize) || 1 << 16,\n  };\n\n  return (opts.runInWorker ? _createBackgroundPlugin : _createForegroundPlugin)(ic, names, moduleData);\n}\n\nexport { createPlugin as newPlugin };\n\nexport default createPlugin;\n"],
  "mappings": "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",
  "names": ["expand", "path", "idx", "_a", "start", "final", "i", "acc", "ext", "_hasMagic", "ext", "qmark", "star", "expand", "regExpEscape", "open", "fetch"]
}
