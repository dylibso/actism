var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/worker.ts
import { parentPort } from "node:worker_threads";

// src/interfaces.ts
var _decoder, _bytes;
var _PluginOutput = class extends DataView {
  constructor(buffer) {
    super(buffer);
    __privateAdd(this, _bytes, null);
  }
  json() {
    return JSON.parse(this.string());
  }
  arrayBuffer() {
    return this.buffer;
  }
  text() {
    return this.string();
  }
  string() {
    return __privateGet(_PluginOutput, _decoder).decode(this.buffer);
  }
  bytes() {
    __privateGet(this, _bytes) ?? __privateSet(this, _bytes, new Uint8Array(this.buffer));
    return __privateGet(this, _bytes);
  }
  setInt8(_byteOffset, _value) {
    throw new Error("Cannot set values on output");
  }
  setInt16(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setInt32(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setUint8(_byteOffset, _value) {
    throw new Error("Cannot set values on output");
  }
  setUint16(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setUint32(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setFloat32(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setFloat64(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setBigInt64(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
  setBigUint64(_byteOffset, _value, _littleEndian) {
    throw new Error("Cannot set values on output");
  }
};
var PluginOutput = _PluginOutput;
_decoder = new WeakMap();
_bytes = new WeakMap();
__privateAdd(PluginOutput, _decoder, new TextDecoder());

// src/polyfills/bun-capabilities.ts
var CAPABILITIES = {
  allowSharedBufferCodec: false,
  manifestSupportsPaths: true,
  crossOriginChecksEnforced: false,
  fsAccess: true,
  hasWorkerCapability: true,
  supportsWasiPreview1: false,
  extismStdoutEnvVarSet: Boolean(process.env.EXTISM_ENABLE_WASI_OUTPUT)
};

// src/call-context.ts
var BEGIN = Symbol("begin");
var END = Symbol("end");
var ENV = Symbol("env");
var GET_BLOCK = Symbol("get-block");
var IMPORT_STATE = Symbol("import-state");
var EXPORT_STATE = Symbol("export-state");
var STORE = Symbol("store-value");
var RESET = Symbol("reset");
var Block = class {
  get byteLength() {
    return this.buffer.byteLength;
  }
  constructor(arrayBuffer, local) {
    this.buffer = arrayBuffer;
    this.view = new DataView(this.buffer);
    this.local = local;
  }
  static indexToAddress(idx) {
    return BigInt(idx) << 48n;
  }
  static addressToIndex(addr) {
    return Number(BigInt(addr) >> 48n);
  }
  static maskAddress(addr) {
    return Number(BigInt(addr) & (1n << 48n) - 1n);
  }
};
var _a;
var CallContext = class {
  constructor(type, logger, config) {
    this.#blocks = [];
    this.#vars = /* @__PURE__ */ new Map();
    this[_a] = {
      alloc: (n) => {
        return this.alloc(n);
      },
      free: (addr) => {
        this.#blocks[Block.addressToIndex(addr)] = null;
      },
      load_u8: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const offset = Block.maskAddress(addr);
        const block = this.#blocks[blockIdx];
        return block?.view.getUint8(Number(offset));
      },
      load_u64: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const offset = Block.maskAddress(addr);
        const block = this.#blocks[blockIdx];
        return block?.view.getBigUint64(Number(offset), true);
      },
      store_u8: (addr, n) => {
        const blockIdx = Block.addressToIndex(addr);
        const offset = Block.maskAddress(addr);
        const block = this.#blocks[blockIdx];
        block?.view.setUint8(Number(offset), Number(n));
      },
      store_u64: (addr, n) => {
        const blockIdx = Block.addressToIndex(addr);
        const offset = Block.maskAddress(addr);
        const block = this.#blocks[blockIdx];
        block?.view.setBigUint64(Number(offset), n, true);
      },
      input_offset: () => {
        const blockIdx = this.#stack[this.#stack.length - 1][0];
        return Block.indexToAddress(blockIdx || 0);
      },
      input_length: () => {
        return BigInt(this.#input?.byteLength ?? 0);
      },
      input_load_u8: (addr) => {
        const offset = Block.maskAddress(addr);
        return this.#input?.view.getUint8(Number(offset));
      },
      input_load_u64: (addr) => {
        const offset = Block.maskAddress(addr);
        return this.#input?.view.getBigUint64(Number(offset), true);
      },
      output_set: (addr, length) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          throw new Error(`cannot assign to this block (addr=${addr.toString(16).padStart(16, "0")}; length=${length})`);
        }
        if (length > block.buffer.byteLength) {
          throw new Error("length longer than target block");
        }
        this.#stack[this.#stack.length - 1][1] = blockIdx;
      },
      error_set: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          throw new Error("cannot assign to this block");
        }
        this.#stack[this.#stack.length - 1][2] = blockIdx;
      },
      config_get: (addr) => {
        const item = this.read(addr);
        if (item === null) {
          return 0n;
        }
        const key = item.string();
        if (key in this.#config) {
          return this.store(this.#config[key]);
        }
        return 0n;
      },
      var_get: (addr) => {
        const item = this.read(addr);
        if (item === null) {
          return 0n;
        }
        const key = item.string();
        return this.#vars.has(key) ? Block.indexToAddress(this.#vars.get(key)) : 0n;
      },
      var_set: (addr, valueaddr) => {
        const item = this.read(addr);
        if (item === null) {
          return 0n;
        }
        const key = item.string();
        if (valueaddr === 0n) {
          this.#vars.delete(key);
          return 0n;
        }
        this.#vars.set(key, Block.addressToIndex(valueaddr));
      },
      http_request: (_requestOffset, _bodyOffset) => {
        this.#logger.error("http_request is not enabled");
        return 0n;
      },
      http_status_code: () => {
        this.#logger.error("http_status_code is not enabled");
        return 0;
      },
      length: (addr) => {
        return this.length(addr);
      },
      length_unsafe: (addr) => {
        return this.length(addr);
      },
      log_warn: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          return this.#logger.error(
            `failed to log(warn): bad block reference in addr 0x${addr.toString(16).padStart(64, "0")}`
          );
        }
        const text = this.#decoder.decode(block.buffer);
        this.#logger.warn(text);
      },
      log_info: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          return this.#logger.error(
            `failed to log(info): bad block reference in addr 0x${addr.toString(16).padStart(64, "0")}`
          );
        }
        const text = this.#decoder.decode(block.buffer);
        this.#logger.info(text);
      },
      log_debug: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          return this.#logger.error(
            `failed to log(debug): bad block reference in addr 0x${addr.toString(16).padStart(64, "0")}`
          );
        }
        const text = this.#decoder.decode(block.buffer);
        this.#logger.debug(text);
      },
      log_error: (addr) => {
        const blockIdx = Block.addressToIndex(addr);
        const block = this.#blocks[blockIdx];
        if (!block) {
          return this.#logger.error(
            `failed to log(error): bad block reference in addr 0x${addr.toString(16).padStart(64, "0")}`
          );
        }
        const text = this.#decoder.decode(block.buffer);
        this.#logger.error(text);
      }
    };
    this.#arrayBufferType = type;
    this.#logger = logger;
    this.#decoder = new TextDecoder();
    this.#encoder = new TextEncoder();
    this.#stack = [];
    this.alloc(1);
    this.#config = config;
  }
  #stack;
  #blocks;
  #logger;
  #decoder;
  #encoder;
  #arrayBufferType;
  #config;
  #vars;
  alloc(size) {
    const block = new Block(new this.#arrayBufferType(Number(size)), true);
    const index = this.#blocks.length;
    this.#blocks.push(block);
    return Block.indexToAddress(index);
  }
  getVariable(name) {
    if (!this.#vars.has(name)) {
      return null;
    }
    return this.read(this.#vars.get(name));
  }
  setVariable(name, value) {
    const newIdx = this[STORE](value);
    if (newIdx === null) {
      return 0n;
    }
    const oldIdx = this.#vars.get(name) ?? null;
    if (oldIdx !== null) {
      this.#blocks[oldIdx] = this.#blocks[newIdx];
      this.#blocks[newIdx] = null;
      if (newIdx === this.#blocks.length - 1) {
        this.#blocks.pop();
      }
    }
    this.#vars.set(name, oldIdx ?? newIdx);
    return Block.indexToAddress(oldIdx ?? newIdx);
  }
  read(addr) {
    const blockIdx = Block.addressToIndex(addr);
    const block = this.#blocks[blockIdx];
    if (!block) {
      return null;
    }
    const buffer = !(block.buffer instanceof ArrayBuffer) && !CAPABILITIES.allowSharedBufferCodec ? new Uint8Array(block.buffer).slice().buffer : block.buffer;
    return new PluginOutput(buffer);
  }
  store(input) {
    const idx = this[STORE](input);
    if (!idx) {
      throw new Error("failed to store output");
    }
    return Block.indexToAddress(idx);
  }
  length(addr) {
    const blockIdx = Block.addressToIndex(addr);
    const block = this.#blocks[blockIdx];
    if (!block) {
      return 0n;
    }
    return BigInt(block.buffer.byteLength);
  }
  get #input() {
    const idx = this.#stack[this.#stack.length - 1][0];
    if (idx === null) {
      return null;
    }
    return this.#blocks[idx];
  }
  [(_a = ENV, RESET)]() {
    this.#blocks.length = 1;
    this.#stack.length = 0;
  }
  [GET_BLOCK](index) {
    const block = this.#blocks[index];
    if (!block) {
      throw new Error(`invalid block index: ${index}`);
    }
    return block;
  }
  [IMPORT_STATE](state, copy = false) {
    for (let [buf, idx] of state.blocks) {
      if (buf && copy) {
        const dst = new Uint8Array(new this.#arrayBufferType(Number(buf.byteLength)));
        dst.set(new Uint8Array(buf));
        buf = dst.buffer;
      }
      this.#blocks[idx] = buf ? new Block(buf, false) : null;
    }
    this.#stack = state.stack;
  }
  [EXPORT_STATE]() {
    return {
      stack: this.#stack.slice(),
      blocks: this.#blocks.map((block, idx) => {
        if (!block) {
          return [null, idx];
        }
        if (block.local) {
          block.local = false;
          return [block.buffer, idx];
        }
        return null;
      }).filter(Boolean)
    };
  }
  [STORE](input) {
    if (!input) {
      return null;
    }
    if (typeof input === "string") {
      input = this.#encoder.encode(input);
    }
    if (input instanceof Uint8Array) {
      if (input.buffer.constructor === this.#arrayBufferType) {
        const idx2 = this.#blocks.length;
        this.#blocks.push(new Block(input.buffer, true));
        return idx2;
      }
      const idx = Block.addressToIndex(this.alloc(input.length));
      const block = this.#blocks[idx];
      const buf = new Uint8Array(block.buffer);
      buf.set(input, 0);
      return idx;
    }
    return input;
  }
  [BEGIN](input) {
    this.#stack.push([input, null, null]);
  }
  [END]() {
    const [, outputIdx, errorIdx] = this.#stack.pop();
    const outputPosition = errorIdx === null ? 1 : 0;
    const idx = errorIdx ?? outputIdx;
    const result = [null, null];
    if (idx === null) {
      return result;
    }
    const block = this.#blocks[idx];
    if (block === null) {
      return result;
    }
    result[outputPosition] = idx;
    return result;
  }
};

// src/polyfills/node-wasi.ts
import { WASI } from "wasi";
import { devNull } from "node:os";
import { open } from "node:fs/promises";
import { closeSync } from "node:fs";
async function createDevNullFDs() {
  const [stdin, stdout] = await Promise.all([open(devNull, "r"), open(devNull, "w")]);
  let needsClose = true;
  let close = async () => {
    closeSync(stdin);
    closeSync(stdout);
  };
  if (typeof stdin !== "number") {
    const fr = new globalThis.FinalizationRegistry((held) => {
      try {
        if (needsClose)
          closeSync(held);
      } catch {
      }
    });
    fr.register(stdin, stdin.fd);
    fr.register(stdout, stdout.fd);
    close = async () => {
      needsClose = false;
      await Promise.all([stdin.close(), stdout.close()]).catch(() => {
      });
    };
  }
  return {
    close,
    fds: [stdin.fd, stdout.fd, stdout.fd]
  };
}
async function loadWasi(allowedPaths, enableWasiOutput) {
  const {
    close,
    fds: [stdin, stdout, stderr]
  } = enableWasiOutput ? { async close() {
  }, fds: [0, 1, 2] } : await createDevNullFDs();
  const context = new WASI({
    version: "preview1",
    preopens: allowedPaths,
    stdin,
    stdout,
    stderr
  });
  return {
    async importObject() {
      return context.wasiImport;
    },
    async close() {
      await close();
    },
    async initialize(instance) {
      const memory = instance.exports.memory;
      if (!memory) {
        throw new Error("The module has to export a default memory.");
      }
      if (instance.exports._initialize) {
        const init = instance.exports._initialize;
        if (context.initialize) {
          context.initialize({
            exports: {
              memory,
              _initialize: () => {
                init();
              }
            }
          });
        } else {
          init();
        }
      } else {
        context.start({
          exports: {
            memory,
            _start: () => {
            }
          }
        });
      }
    }
  };
}

// src/foreground-plugin.ts
var EXTISM_ENV = "extism:host/env";
var ForegroundPlugin = class {
  #context;
  #modules;
  #names;
  #active = false;
  #wasi;
  constructor(context, names, modules, wasi) {
    this.#context = context;
    this.#names = names;
    this.#modules = modules;
    this.#wasi = wasi;
  }
  async reset() {
    if (this.isActive()) {
      return false;
    }
    this.#context[RESET]();
    return true;
  }
  isActive() {
    return this.#active;
  }
  async functionExists(funcName) {
    try {
      const search = [].concat(funcName);
      const [target, name] = search.length === 2 ? [this.lookupTarget(search[0]), search[1]] : [
        this.#modules.find((guest) => {
          const exports = WebAssembly.Module.exports(guest.module);
          return exports.find((item) => {
            return item.name === search[0] && item.kind === "function";
          });
        }),
        search[0]
      ];
      if (!target) {
        return false;
      }
      const func = target.instance.exports[name];
      if (!func) {
        return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  async callBlock(funcName, input) {
    this.#active = true;
    const search = [].concat(funcName);
    const [target, name] = search.length === 2 ? [this.lookupTarget(search[0]), search[1]] : [
      this.#modules.find((guest) => {
        const exports = WebAssembly.Module.exports(guest.module);
        return exports.find((item) => {
          return item.name === search[0] && item.kind === "function";
        });
      }),
      search[0]
    ];
    if (!target) {
      throw Error(`Plugin error: target "${search.join('" "')}" does not exist`);
    }
    const func = target.instance.exports[name];
    if (!func) {
      throw Error(`Plugin error: function "${search.join('" "')}" does not exist`);
    }
    this.#context[BEGIN](input ?? null);
    try {
      func();
      return this.#context[END]();
    } catch (err) {
      this.#context[END]();
      throw err;
    } finally {
      this.#active = false;
    }
  }
  async call(funcName, input) {
    const inputIdx = this.#context[STORE](input);
    const [errorIdx, outputIdx] = await this.callBlock(funcName, inputIdx);
    const shouldThrow = errorIdx !== null;
    const idx = errorIdx ?? outputIdx;
    if (idx === null) {
      return null;
    }
    const block = this.#context[GET_BLOCK](idx);
    if (!block) {
      return null;
    }
    const output = new PluginOutput(block.buffer);
    if (shouldThrow) {
      throw new Error(`Plugin-originated error: ${output.string()}`);
    }
    return output;
  }
  lookupTarget(name) {
    const target = String(name ?? "0");
    const idx = this.#names.findIndex((xs) => xs === target);
    if (idx === -1) {
      throw new Error(`no module named "${name}"`);
    }
    return this.#modules[idx];
  }
  async getExports(name) {
    return WebAssembly.Module.exports(this.lookupTarget(name).module) || [];
  }
  async getImports(name) {
    return WebAssembly.Module.imports(this.lookupTarget(name).module) || [];
  }
  async getInstance(name) {
    return this.lookupTarget(name).instance;
  }
  async close() {
    if (this.#wasi) {
      await this.#wasi.close();
      this.#wasi = null;
    }
  }
};
async function createForegroundPlugin(opts, names, modules, context = new CallContext(ArrayBuffer, opts.logger, opts.config)) {
  const wasi = opts.wasiEnabled ? await loadWasi(opts.allowedPaths, opts.enableWasiOutput) : null;
  const imports = {
    ...wasi ? { wasi_snapshot_preview1: await wasi.importObject() } : {},
    [EXTISM_ENV]: context[ENV],
    env: {}
  };
  for (const namespace in opts.functions) {
    imports[namespace] = imports[namespace] || {};
    for (const func in opts.functions[namespace]) {
      imports[namespace][func] = opts.functions[namespace][func].bind(null, context);
    }
  }
  const instances = await Promise.all(
    modules.map(async (module) => {
      const instance = await WebAssembly.instantiate(module, imports);
      if (wasi) {
        await wasi?.initialize(instance);
      }
      const guestType = instance.exports.hs_init ? "haskell" : instance.exports._initialize ? "reactor" : instance.exports._start ? "command" : "none";
      const initRuntime = instance.exports.hs_init ? instance.exports.hs_init : () => {
      };
      initRuntime();
      return { module, instance, guestType };
    })
  );
  return new ForegroundPlugin(context, names, instances, wasi);
}

// src/worker.ts
var MAX_WAIT = 5e3;
var Reactor = class {
  constructor(port) {
    if (!port) {
      throw new Error("This should be unreachable: this module should only be invoked as a web worker.");
    }
    this.sharedData = null;
    this.sharedDataView = null;
    this.hostFlag = null;
    this.port = port;
    this.port.on("message", (ev) => this.handleMessage(ev));
    this.port.postMessage({ type: "initialized" });
    this.dynamicHandlers = /* @__PURE__ */ new Map();
    this.dynamicHandlers.set(
      "call",
      async (transfer, name, input, state) => {
        if (!this.context) {
          throw new Error("invalid state: no context available to worker reactor");
        }
        this.context[IMPORT_STATE](state);
        const results = await this.plugin?.callBlock(name, input).then(
          (indices) => [null, indices],
          (err) => [err, null]
        );
        state = this.context[EXPORT_STATE]();
        for (const [block] of state.blocks) {
          if (block) {
            transfer.push(block);
          }
        }
        if (results[0]) {
          results[0] = {
            originalStack: results[0]?.stack,
            message: results[0]?.message
          };
        }
        return { results, state };
      }
    );
    this.dynamicHandlers.set("reset", async (_txf) => {
      return this.plugin?.reset();
    });
    this.dynamicHandlers.set("getExports", async (_txf, name) => {
      return this.plugin?.getExports(name);
    });
    this.dynamicHandlers.set("getImports", async (_txf, name) => {
      return this.plugin?.getImports(name);
    });
    this.dynamicHandlers.set("functionExists", async (_txf, name) => {
      return this.plugin?.functionExists(name);
    });
  }
  async handleMessage(ev) {
    switch (ev.type) {
      case "init":
        return await this.handleInit(ev);
      case "invoke":
        return await this.handleInvoke(ev);
    }
  }
  async handleInvoke(ev) {
    const handler = this.dynamicHandlers.get(ev.handler);
    if (!handler) {
      return this.port.postMessage({
        type: "return",
        result: [`no handler registered for ${ev.handler}`, null]
      });
    }
    const transfer = [];
    const results = await handler(transfer, ...ev.args || []).then(
      (ok) => [null, ok],
      (err) => [err, null]
    );
    if (results[0]) {
      results[0] = {
        originalStack: results[0]?.stack,
        message: results[0]?.message
      };
    }
    return this.port.postMessage(
      {
        type: "return",
        results
      },
      transfer
    );
  }
  async handleInit(ev) {
    this.sharedData = ev.sharedData;
    this.sharedDataView = new DataView(ev.sharedData);
    this.hostFlag = new Int32Array(this.sharedData);
    const functions = Object.fromEntries(
      Object.entries(ev.functions).map(([namespace, funcs]) => {
        return [
          namespace,
          Object.fromEntries(
            funcs.map((funcName) => {
              return [
                funcName,
                (context, ...args) => this.callHost(context, namespace, funcName, args)
              ];
            })
          )
        ];
      })
    );
    const { type: _, modules, functions: __, ...opts } = ev;
    const logLevel = (level) => (message) => this.port.postMessage({ type: "log", level, message });
    const logger = Object.fromEntries(
      ["info", "debug", "warn", "error"].map((lvl) => [lvl, logLevel(lvl)])
    );
    this.context = new CallContext(ArrayBuffer, logger, ev.config);
    this.plugin = await createForegroundPlugin(
      { ...opts, functions, fetch, logger },
      ev.names,
      modules,
      this.context
    );
    this.port.postMessage({ type: "ready" });
  }
  callHost(context, namespace, func, args) {
    if (!this.hostFlag) {
      throw new Error("attempted to call host before receiving shared array buffer");
    }
    const state = context[EXPORT_STATE]();
    this.port.postMessage({
      type: "invoke",
      namespace,
      func,
      args,
      state
    });
    const reader = new RingBufferReader(this.sharedData);
    const blocks = [];
    let retval;
    do {
      const sectionType = reader.readUint8();
      switch (sectionType) {
        case 0:
          state.blocks = blocks;
          context[IMPORT_STATE](state);
          reader.close();
          this.hostFlag[0] = RingBufferReader.SAB_BASE_OFFSET;
          return retval;
        case 1:
          retval = reader.readUint64();
          break;
        case 2:
          retval = reader.readFloat64();
          break;
        case 3:
          retval = void 0;
          break;
        case 4:
          {
            const index = reader.readUint32();
            const len = reader.readUint32();
            if (!len) {
              blocks.push([null, index]);
            } else {
              const output = new Uint8Array(len);
              reader.read(output);
              blocks.push([output.buffer, index]);
            }
          }
          break;
        default:
          throw new Error(
            `invalid section type="${sectionType}"; please open an issue (https://github.com/extism/js-sdk/issues/new?title=shared+array+buffer+bad+section+type+${sectionType}&labels=bug)`
          );
          break;
      }
    } while (1);
  }
};
new Reactor(parentPort);
var _RingBufferReader = class {
  constructor(input) {
    this.input = input;
    this.inputOffset = _RingBufferReader.SAB_BASE_OFFSET;
    this.flag = new Int32Array(this.input);
    this.scratch = new ArrayBuffer(8);
    this.scratchView = new DataView(this.scratch);
    this.expected = 0;
    this.pull(false);
  }
  get available() {
    return this.flag[0] - this.inputOffset;
  }
  close() {
    while (Atomics.compareExchange(this.flag, _RingBufferReader.SAB_IDX, this.expected, _RingBufferReader.SAB_BASE_OFFSET) !== _RingBufferReader.SAB_BASE_OFFSET) {
    }
    Atomics.notify(this.flag, _RingBufferReader.SAB_IDX, MAX_WAIT);
  }
  pull(reset = true) {
    if (reset) {
      while (Atomics.compareExchange(
        this.flag,
        _RingBufferReader.SAB_IDX,
        this.expected,
        _RingBufferReader.SAB_BASE_OFFSET
      ) !== _RingBufferReader.SAB_BASE_OFFSET) {
      }
      Atomics.notify(this.flag, _RingBufferReader.SAB_IDX, MAX_WAIT);
    }
    const v = Atomics.wait(this.flag, 0, _RingBufferReader.SAB_BASE_OFFSET, MAX_WAIT);
    this.expected = Atomics.load(this.flag, 0);
    if (v === "timed-out") {
      throw new Error(`Worker timed out waiting for response from host after ${MAX_WAIT}ms ${this.flag[0]}`);
    }
    this.inputOffset = _RingBufferReader.SAB_BASE_OFFSET;
  }
  read(output) {
    if (output.byteLength < this.available) {
      output.set(new Uint8Array(this.input).subarray(this.inputOffset, this.inputOffset + output.byteLength));
      this.inputOffset += output.byteLength;
      return;
    }
    let outputOffset = 0;
    let extent = this.available;
    do {
      output.set(new Uint8Array(this.input).subarray(this.inputOffset, this.inputOffset + extent), outputOffset);
      outputOffset += extent;
      this.inputOffset += extent;
      if (outputOffset === output.byteLength) {
        break;
      }
      if (this.available < 0) {
        break;
      }
      this.pull();
      extent = Math.min(Math.max(this.available, 0), output.byteLength - outputOffset);
    } while (outputOffset !== output.byteLength);
  }
  readUint8() {
    this.read(new Uint8Array(this.scratch).subarray(0, 1));
    return this.scratchView.getUint8(0);
  }
  readUint32() {
    this.read(new Uint8Array(this.scratch).subarray(0, 4));
    return this.scratchView.getUint32(0, true);
  }
  readUint64() {
    this.read(new Uint8Array(this.scratch));
    return this.scratchView.getBigUint64(0, true);
  }
  readFloat64() {
    this.read(new Uint8Array(this.scratch));
    return this.scratchView.getFloat64(0, true);
  }
};
var RingBufferReader = _RingBufferReader;
RingBufferReader.SAB_IDX = 0;
RingBufferReader.SAB_BASE_OFFSET = 4;
//# sourceMappingURL=worker.js.map
